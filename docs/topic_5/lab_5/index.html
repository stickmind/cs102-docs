<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="next" title="作业 5：来一点汇编" href="../assign_5/index.html" /><link rel="prev" title="汇编工具" href="../asm_tools/index.html" />

    
    <link rel="shortcut icon" href="_static/favicon.ico"/>
        <title>实验 5：汇编和运行时栈 - CS102 文档</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../../_static/pied-piper-admonition.css?v=e32e2275" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<div class="announcement">
  <aside class="announcement-content">
     天将降大任于斯人也，必先苦其心志 
  </aside>
</div>

<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">CS102 文档</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">CS102 文档</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_0.html">开发环境</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 开发环境</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_0/linux_intro/index.html">Linux 介绍</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Linux 介绍</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/linux_intro/linux_on_windows.html">Windows MSYS2 环境</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/linux_intro/linux_virtual_box.html">Ubuntu 虚拟机</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_0/command_line/linux_command.html">Linux 命令行</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Linux 命令行</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/command_line/basic.html">基本命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/command_line/file_operation.html">文件操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/command_line/searching.html">文件搜索</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_0/from_cxx_to_c/from_cxx_to_c.html">从 C++ 到 C</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of 从 C++ 到 C</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/from_cxx_to_c/simpio.html">simpio.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/from_cxx_to_c/strlib.html">strlib.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/from_cxx_to_c/pig_latin.html">Pig Latin</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_0/lab_0/index.html">实验 0：上手 Linux 开发环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_0/assign_0/index.html">作业 0：使用 Linux 和 C</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_1.html">数据的表示</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 数据的表示</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/bit_byte/index.html">位、字节和进制</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_1/int_representation/index.html">整数的表示</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of 整数的表示</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_1/int_representation/index2.html">整型溢出和转换</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/bit_level_ops/index.html">位运算及其应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/lab_1/index.html">实验 1. 数据的表示</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/assign_1/index.html">作业 1. 有趣的位</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_2.html">数组和指针</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of 数组和指针</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_2/string/index.html">字符串</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of 字符串</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_2/string/string.html">字符串表示</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_2/string/string-h.html">string.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_2/string/char-star.html">字符串指针</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_2/array_and_pointer/index.html">数组和指针</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of 数组和指针</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_2/array_and_pointer/star-pointer.html">理解 <code class="docutils literal notranslate"><span class="pre">*p</span></code> 的特殊性</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_2/array_and_pointer/array_and_pointer_ops.html">数组索引和指针运算</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_2/array_and_pointer/array_and_pointer_mis.html">多维数组和二级指针</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_2/function_paremeters/index.html">函数参数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_2/lab_2/index.html">实验 2. 数组和指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_2/assign_2/index.html">作业 2. C 字符串</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_3.html">栈和堆</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of 栈和堆</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../topic_3/memory_layout/index.html">内存布局</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_3/memeory_management/index.html">内存管理</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_3/struct/index.html">结构体</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of 结构体</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_3/struct/stack_adt.html">设计栈抽象数据类型</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_3/lab_3/index.html">实验 3：栈和堆</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_3/assign_3/index.html">作业 3：有趣的堆</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_4.html">泛型编程</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of 泛型编程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../topic_4/void_pointer/index.html">泛型指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_4/function_pointer/index.html">函数指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_4/lab_4/index.html">实验 4：泛型和回调</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_4/assign_4/index.html">作业 4：深入泛型指针</a></li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../topic_5.html">汇编语言</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle navigation of 汇编语言</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 has-children"><a class="reference internal" href="../asm_intro/index.html">汇编概述</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle navigation of 汇编概述</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../asm_intro/index2.html">程序员视角下的硬件</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../x86-64_asm/index.html">x86-64 指令</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle navigation of x86-64 指令</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../x86-64_asm/data_move.html">数据传送指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../x86-64_asm/arithmetic_and_logic.html">算术与逻辑指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../x86-64_asm/control.html">控制指令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../asm_tools/index.html">汇编工具</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">实验 5：汇编和运行时栈</a></li>
<li class="toctree-l2"><a class="reference internal" href="../assign_5/index.html">作业 5：来一点汇编</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>返回顶部</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>实验 5：汇编和运行时栈<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<p>本次实验将进一步理解 C 语言和汇编之间的关系，同时还会练习使用反汇编工具 <code class="docutils literal notranslate"><span class="pre">objdump</span></code>，以及使用 GDB 进行调试汇编程序和函数调用栈，并能够将函数栈帧与运行时程序的状态联系起来。这些内容对程序调试非常有用。</p>
<p>理解 C 代码与其汇编指令之间的关系，以及从汇编到 C 的逆向工程练习，可以为下一次作业做好充分的准备。</p>
<p>以下一些问题用于检测你的理解，并让你进一步思考这些概念：</p>
<ul class="simple">
<li><p>举一个 C 表达式的例子，可以编译成不同但却等效的汇编指令。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sar</span></code> 和 <code class="docutils literal notranslate"><span class="pre">shr</span></code> 之间有什么区别？</p></li>
<li><p>函数的返回值是如何从被调函数传递给主调函数的？</p></li>
<li><p>什么样的行为可能表明 <code class="docutils literal notranslate"><span class="pre">lea</span></code> 指令是在进行地址计算，而不是算术运算？</p></li>
<li><p>如果变量在 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 报告中显示 <code class="docutils literal notranslate"><span class="pre">&lt;optimized</span> <span class="pre">out&gt;</span></code>，如果获得该变量的值？</p></li>
<li><p>为什么用于函数参数的寄存器是完全固定的，但对于本地变量（local variable）却没有任何约定的位置？</p></li>
<li><p>为什么要区分 <strong>caller-owned</strong> 寄存器和 <strong>callee-owned</strong> 寄存器？相比于不作区分，这种设计的优势是什么？</p></li>
<li><p>如何根据给定的汇编代码为函数绘制栈帧图。</p></li>
</ul>
<section id="id2">
<h2>学习目标<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>练习使用 GDB 调试汇编代码</p></li>
<li><p>学习 C 源码和汇编转换的关系</p></li>
<li><p>观察并理解运行时栈的执行机制</p></li>
<li><p>分析运行时栈相关的错误</p></li>
</ul>
</section>
<section id="id3">
<h2>初始代码<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>你的个人用户目录下应该已经有 <code class="docutils literal notranslate"><span class="pre">cs102</span></code> 这个文件夹了，通过下面的命令拷贝初始代码到该目录中：</p>
<div class="highlight-Shell notranslate"><div class="highlight"><pre><span></span>cp<span class="w"> </span>-r<span class="w"> </span>/home/cs102-shared/labs/lab5<span class="w"> </span>~/cs102
</pre></div>
</div>
<div class="hint admonition">
<p class="admonition-title">提示</p>
<p>初始项目内置了一些陷阱，如果编译过程中报告了错误，这属于正常情况，不必担心。</p>
</div>
</section>
<section id="gdb">
<h2>任务 1：GDB 调试汇编<a class="headerlink" href="#gdb" title="Link to this heading">#</a></h2>
<p>一起练习一下 GDB 汇编相关的命令。</p>
<ol class="arabic simple">
<li><p>通读 <code class="docutils literal notranslate"><span class="pre">code.c</span></code> 程序代码。</p></li>
<li><p>编译程序并使用 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 进行调试。反汇编出 <code class="docutils literal notranslate"><span class="pre">myfn</span></code> 函数的汇编指令。</p></li>
<li><p>使用反汇编找出 <code class="docutils literal notranslate"><span class="pre">arr</span></code> 的存储位置（提示：查看第一个 <code class="docutils literal notranslate"><span class="pre">mov</span></code> 指令，<code class="docutils literal notranslate"><span class="pre">%rsp</span></code> 是指向当前栈顶的指针）。<code class="docutils literal notranslate"><span class="pre">arr</span></code> 中的值是如何初始化的？初始化最后一个数组元素时，对字符串常量进行的 <code class="docutils literal notranslate"><span class="pre">strlen</span></code> 调用发生了什么？</p></li>
<li><p>对 <code class="docutils literal notranslate"><span class="pre">count</span></code> 进行赋值的时候，生成了哪些指令？关于 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 运算符，我们能得出什么结论？汇编指令会调用实际的函数吗？</p></li>
<li><p>在函数 <code class="docutils literal notranslate"><span class="pre">myfn</span></code> 处设置断点并运行程序。使用命令 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">locals</span></code> 显示局部变量。将此列表与 C 源代码中的声明进行比较。你会看到一些变量显示“实时”的值，另一些却只显示 <code class="docutils literal notranslate"><span class="pre">&lt;optimized</span> <span class="pre">out&gt;</span></code>。</p></li>
<li><p>尝试在汇编层面调试，找出哪个寄存器存储了 <code class="docutils literal notranslate"><span class="pre">total</span></code> 的值，哪个寄存器存储了 <code class="docutils literal notranslate"><span class="pre">squared</span></code> 的值？注意，寄存器可以被多个变量进行复用。</p></li>
</ol>
</section>
<section id="id4">
<h2>任务 2：汇编指令练习<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>学习 C 到汇编的转换，建议尝试 Compiler Explorer 在线工具，这是一款便利的“交互式编译器”。</p>
<p>此<a class="reference external" href="https://godbolt.org/z/o831K37hd">链接</a>参照课程和实验中的 <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> 编译器标志，已经预先为你配置好。如果想手动配置自己环境：语言选择 C，编译器版本选择 <code class="docutils literal notranslate"><span class="pre">x86-64</span> <span class="pre">gcc</span> <span class="pre">11.4</span></code> 并输入标志 <code class="docutils literal notranslate"><span class="pre">-Og</span> <span class="pre">-std=gnu99</span></code>。</p>
<p>在 Compiler Explorer 中，你可以输入 C 函数，查看其生成的汇编代码。调整 C 的源代码后，可以观察这些更改如何反映在汇编指令中。你可以在服务器上使用 <code class="docutils literal notranslate"><span class="pre">gcc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 进行相同的观察，但 Compiler Explorer 提供了一个方便的测试环境，可以更轻松地完成这些任务。试试看吧！</p>
<section id="id5">
<h3>移动和地址模式<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p>打开 Compiler Explorer 提前写好的代码<a class="reference external" href="https://godbolt.org/z/5GvbEe6Yc">链接</a>，查看下面两个 <code class="docutils literal notranslate"><span class="pre">deref</span></code> 函数的汇编代码。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">deref_one</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">deref_two</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>花点时间通读 <code class="docutils literal notranslate"><span class="pre">mov</span></code> 指令。该指令在做什么？它与其所代表的 C 代码有何联系？</p></li>
<li><p>这两个函数的汇编指令序列有一处不同。不同之处是什么？为什么会有这个差别？</p></li>
<li><p>编辑这两个函数，使用 <code class="docutils literal notranslate"><span class="pre">ptr[7]</span></code> 替换 <code class="docutils literal notranslate"><span class="pre">*ptr</span></code>。这会如何改变 <code class="docutils literal notranslate"><span class="pre">mov</span></code> 指令目标操作数的寻址模式？两个 <code class="docutils literal notranslate"><span class="pre">deref</span></code> 函数是否以相同的方式变化？</p></li>
<li><p>再次编辑这两个函数，使用 <code class="docutils literal notranslate"><span class="pre">ptr[index]</span></code> 替换 <code class="docutils literal notranslate"><span class="pre">ptr[7]</span></code>。这会如何改变 <code class="docutils literal notranslate"><span class="pre">mov</span></code> 指令目标操作数的寻址模式？两个 <code class="docutils literal notranslate"><span class="pre">deref</span></code> 函数是否以相同的方式变化？</p></li>
<li><p>将整个赋值语句更改为 <code class="docutils literal notranslate"><span class="pre">ptr[0]</span> <span class="pre">=</span> <span class="pre">ptr[1]</span></code>。对于这两个函数，汇编代码都增加了一条指令。上述所有操作，都只需要一条 <code class="docutils literal notranslate"><span class="pre">mov</span></code> 指令。该赋值语句却需要两个 <code class="docutils literal notranslate"><span class="pre">mov</span></code>。为什么？</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">补充</p>
<p>你可能会疑惑，为什么只需要移动一个字节，编译器却使用了 <code class="docutils literal notranslate"><span class="pre">movzbl</span></code> 指令。在这种情况下，虽然移动一个字节是可行的，但编译器会做出选择，它认为这样可以使程序的执行更高效。</p>
<p>参考阅读<a class="reference external" href="https://en.wikipedia.org/wiki/Register_renaming">指令级别的并行处理</a>。</p>
</div>
<p>打开 Compiler Explorer 提前写好的代码<a class="reference external" href="https://godbolt.org/z/bxhdbGae4">链接</a>，查看下面两个 <code class="docutils literal notranslate"><span class="pre">deref</span></code> 函数的汇编代码。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">coord</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">coord</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">deref_three</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">coord</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">deref_two</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>花点时间阅读 <code class="docutils literal notranslate"><span class="pre">mov</span></code> 指令。它做了什么？它与其所代表的 C 代码有何联系？</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deref_third</span></code> 与 <code class="docutils literal notranslate"><span class="pre">deref_two</span></code> 的汇编指令完全相同，但是这两个函数的 C 源代码似乎彼此无关！为什么生成了相同的汇编指令？</p></li>
</ul>
</section>
<section id="id6">
<h3>整型算术运算<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>接下来探索一下汇编中的算术运算。<code class="docutils literal notranslate"><span class="pre">add</span></code>、<code class="docutils literal notranslate"><span class="pre">subl</span></code> 和 <code class="docutils literal notranslate"><span class="pre">imul</span></code> 指令分别执行加法、减法和乘法。以下是这些指令的格式：</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">add</span><span class="w"> </span><span class="no">src</span><span class="p">,</span><span class="w"> </span><span class="no">dst</span><span class="w">       </span><span class="c1"># dst += src</span>
<span class="nf">sub</span><span class="w"> </span><span class="no">src</span><span class="p">,</span><span class="w"> </span><span class="no">dst</span><span class="w">       </span><span class="c1"># dst -= src</span>
<span class="nf">imul</span><span class="w"> </span><span class="no">src</span><span class="p">,</span><span class="w"> </span><span class="no">dst</span><span class="w">      </span><span class="c1"># dst *= src</span>
</pre></div>
</div>
<p>以下两个函数对其参数执行相同的算术运算，但这些参数的类型（符号）不同：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">signed_arithmetic</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">unsigned_arithmetic</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>打开 Compiler Explorer 提前写好的代码<a class="reference external" href="https://godbolt.org/z/b9TMdTM1Y">链接</a>，查看两个函数的汇编代码。</p>
<ul class="simple">
<li><p>两个函数生成相同的汇编指令序列！由此可见，2 的补码表示允许 <code class="docutils literal notranslate"><span class="pre">add/sub/imul</span></code> 指令同时适用于无符号和有符号两种类型。非常聪明的设计！</p></li>
<li><p>编辑这两个函数，在开头添加：<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;&gt;=</span> <span class="pre">b;</span></code>。该语句对其中一个参数执行右移操作。执行右移时，<code class="docutils literal notranslate"><span class="pre">gcc</span></code> 会生成算术移位 <code class="docutils literal notranslate"><span class="pre">sar</span></code> 或逻辑移位 <code class="docutils literal notranslate"><span class="pre">shr</span></code> 指令吗？和参数有/无符号有关系吗？</p></li>
<li><p>对于移位指令，移位量可以是立即数，也可以是字节寄存器 <code class="docutils literal notranslate"><span class="pre">%cl</span></code>（且只能是该寄存器）。然而，该指令以一种略微有趣的方式解释 <code class="docutils literal notranslate"><span class="pre">%cl</span></code> 寄存器的内容。回顾该部分知识点以及上述汇编代码，特别是 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;&gt;=</span> <span class="pre">b</span></code> 的汇编指令。对于无符号整型，使用 <code class="docutils literal notranslate"><span class="pre">%cl</span></code> 寄存器可以指定的最大移位量是多少？为什么这个限制是合理的？</p></li>
</ul>
</section>
<section id="id7">
<h3>加载有效地址<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>指令 <code class="docutils literal notranslate"><span class="pre">lea</span></code> 原本是用于移动内存的地址，但在实际应用中，也常用于算术运算。它可以将多个计算步骤打包在一条指令中，可以一次执行两次加法和一次乘法（注意乘法系数只能为 1、2、4 或 8）。编译器经常使用它来执行高效的加法/乘法组合。</p>
<p>打开 Compiler Explorer 提前写好的代码<a class="reference external" href="https://godbolt.org/z/dG5e6afnj">链接</a>，查看以下函数的汇编代码。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>在生成的汇编代码中，你会看到 <code class="docutils literal notranslate"><span class="pre">lea</span></code> 指令而不是预期的 <code class="docutils literal notranslate"><span class="pre">add</span></code> 指令。这很有趣的！尝试了解一下 <code class="docutils literal notranslate"><span class="pre">lea</span></code> 指令在这里的作用，理解为什么在这种情况下 <code class="docutils literal notranslate"><span class="pre">lea</span></code> 可以用于 <code class="docutils literal notranslate"><span class="pre">add</span></code>。它还能做哪些计算呢？一起来看看吧！</p></li>
<li><p>编辑 <code class="docutils literal notranslate"><span class="pre">combine</span></code> 函数，修改返回值为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">y</span></code>，然后再修改为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">8</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">-</span> <span class="pre">17</span></code>，观察单条 <code class="docutils literal notranslate"><span class="pre">lea</span></code> 指令是如何计算这些更复杂的表达式的。</p></li>
<li><p>现在再将返回值修改为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">47</span> <span class="pre">*</span> <span class="pre">y</span></code>，由于乘法因子不再是特殊值，结果将不再适用 <code class="docutils literal notranslate"><span class="pre">lea</span></code> 的模式。此时生成的汇编指令是什么？</p></li>
</ul>
</section>
<section id="id8">
<h3>乘法运算<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p>乘法操作是比较耗时的指令之一，编译器会尽可能选择更高效的替代方案。尝试输入以下代码：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>函数 <code class="docutils literal notranslate"><span class="pre">scale</span></code> 将参数乘以 4。看看编译器生成的汇编代码，有没有乘法指令。编译器用什么指令来代替？（注：加零没有任何作用，只是编译器由于某种原因输出了） 修改 <code class="docutils literal notranslate"><span class="pre">scale</span></code> 函数返回值为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">16</span></code>。现在使用什么汇编指令？</p></li>
<li><p>由于二进制的底层表示，编译器会将 2 的幂相关乘法进行特殊处理，这一点毋庸置疑，但它还有更多技巧！编辑 <code class="docutils literal notranslate"><span class="pre">scale</span></code> 函数，将其参数乘以一个不是 2 的幂的较小常数，例如 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">3</span></code>、<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">7</span></code>、<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">12</span></code>、<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">17</span></code> 等等。观察每个表达式生成的汇编代码，看看究竟用了哪些指令。由此可见，GCC 会竭尽全力避免耗时的乘法操作！</p></li>
<li><p>尝试找到一个最小正整数常量 <code class="docutils literal notranslate"><span class="pre">C</span></code>，使得 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">C</span></code> 的汇编代码为实际的 <code class="docutils literal notranslate"><span class="pre">imul</span></code> 指令。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">补充</p>
<p>在探索乘法操作时，你可能会遇到另一种更罕见的 <code class="docutils literal notranslate"><span class="pre">imul</span></code> 形式。这种形式需要 3 个参数，分别表示 <code class="docutils literal notranslate"><span class="pre">src1</span></code>、<code class="docutils literal notranslate"><span class="pre">src2</span></code>、<code class="docutils literal notranslate"><span class="pre">dst</span></code>。计算过程是将两个 <code class="docutils literal notranslate"><span class="pre">src</span></code> 相乘并将结果放入 <code class="docutils literal notranslate"><span class="pre">dst</span></code> 中。参数 <code class="docutils literal notranslate"><span class="pre">dst</span></code> 必须是寄存器，<code class="docutils literal notranslate"><span class="pre">src1</span></code> 必须是立即数，<code class="docutils literal notranslate"><span class="pre">src2</span></code> 可以是寄存器或内存位置。</p>
</div>
</section>
<section id="id9">
<h3>除法运算<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<p>对于现代 CPU 来说，除法也是一件头疼的事情。因此，GCC 尽可能避免除法运算。一起来看看究竟使用了什么魔法。</p>
<p>打开 Compiler Explorer 提前写好的代码<a class="reference external" href="https://godbolt.org/z/sTWj1PsbK">链接</a>，查看以下函数的汇编代码。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">unsigned_division</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>在为 <code class="docutils literal notranslate"><span class="pre">unsigned_division</span></code> 生成的汇编代码中，我们看不到 <code class="docutils literal notranslate"><span class="pre">div</span></code> 除法指令。那么它是如何实现无符号整数除以 2 的呢？单操作数 <code class="docutils literal notranslate"><span class="pre">shr</span></code> 指令的作用是什么？</p></li>
<li><p>修改除数为其他值，例如 4、8、64。此时生成的汇编代码有什么变化？</p></li>
</ul>
<p>将函数恢复到其原始返回值 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">2</span></code> 并添加以下代码：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">signed_division</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>加法、减法和乘法对有符号和无符号整数的运算是等效的，但除法则不然。如果不能整除，则必须对商进行四舍五入（术语为 <code class="docutils literal notranslate"><span class="pre">DIVIDEND</span> <span class="pre">/</span> <span class="pre">DIVISOR</span> <span class="pre">=</span> <span class="pre">QUOTIENT</span></code>）。在将奇数除以 2 的情况下，余数为 1。丢弃余数具有向下舍入到较小值的效果，无符号整数的除法通过移走 <code class="docutils literal notranslate"><span class="pre">lsb</span></code> 实现类似的效果。然而，整数除法的规则是商必须向零舍入，例如 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">1</span></code>，<code class="docutils literal notranslate"><span class="pre">-3</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">-1</span></code>。正商向下舍入，负商向上舍入。</p>
<ul class="simple">
<li><p>这里假设是算术右移，对数字 <code class="docutils literal notranslate"><span class="pre">3</span></code> 执行 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">&gt;&gt;</span> <span class="pre">1</span></code> 后的位模式是什么？对数字 <code class="docutils literal notranslate"><span class="pre">-3</span></code> 执行 <code class="docutils literal notranslate"><span class="pre">-3</span> <span class="pre">&gt;&gt;</span> <span class="pre">1</span></code> 后的位模式又是什么？你能明白为什么算术右移（丢弃 <code class="docutils literal notranslate"><span class="pre">lsb</span></code>）会将正值四舍五入到零值方向，而将负值四舍五入到背离零值方向吗？这种舍入差异说明，如果值为负数时，仅算术右移是不够的。</p></li>
<li><p>比较 <code class="docutils literal notranslate"><span class="pre">unsigned_division</span></code> 与 <code class="docutils literal notranslate"><span class="pre">signed_division</span></code> 的汇编指令。有符号整型版本插入了一对指令（<code class="docutils literal notranslate"><span class="pre">shr</span></code>、<code class="docutils literal notranslate"><span class="pre">add</span></code>）并使用算术右移 <code class="docutils literal notranslate"><span class="pre">sar</span></code> 代替逻辑右移 <code class="docutils literal notranslate"><span class="pre">shr</span></code>。考虑最后的 <code class="docutils literal notranslate"><span class="pre">sar</span></code> 替代操作。如果移位的数字是正数，则没有任何区别，但如果移位的数字是负数，则算术右移与逻辑右移的影响将非常明显。其区别是什么呢？</p></li>
<li><p>现在让我们深入研究有符号整型版本中插入的 <code class="docutils literal notranslate"><span class="pre">shr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">add</span></code> 指令。追踪这两个指令的操作，当 <code class="docutils literal notranslate"><span class="pre">x</span></code> 为正数时，这些指令没有改变 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的值；而当 <code class="docutils literal notranslate"><span class="pre">x</span></code> 为负数时，这些指令会以一个固定的修正值，将其向零修正到除数最近的倍数，这样可以在作除法时实现适当舍入。</p></li>
<li><p>对于不同的除数，修正值也不同。除数为 2 时，修正值为 1；除数为 4 时，修正值为 3；除数为 8 时，修正值为 7；依此类推。这样的操作逻辑和实验 1 中的 <code class="docutils literal notranslate"><span class="pre">roundup</span></code> 函数很类似！将 <code class="docutils literal notranslate"><span class="pre">signed_division</span></code> 函数改为除以 4，看看修正值是否为 3。</p></li>
<li><p>当除数为 4 时，汇编代码在处理修正量的方式上略有不同。这里根据 <code class="docutils literal notranslate"><span class="pre">test</span></code> 指令的结果判断 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的正负，再使用条件移动指令 <code class="docutils literal notranslate"><span class="pre">cmov</span></code> 进行修正。</p></li>
</ul>
<p>可以进一步探索：如果除数不是 2 的倍数时，又将如何处理？打开 Compiler Explorer 提前写好的代码<a class="reference external" href="https://godbolt.org/z/7vjsEEvWG">链接</a>，查看以下函数的汇编代码。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">unsigned_div10</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>汇编代码显示同样没有使用除法指令，但却乘了一个奇怪的数字 <code class="docutils literal notranslate"><span class="pre">3435973837</span></code>（十六进制为 <code class="docutils literal notranslate"><span class="pre">0xcccccccd</span></code>）。这神奇的操作其实是将“除以 10”替换成了“乘以 1/10”。这里的 <code class="docutils literal notranslate"><span class="pre">1/10</span></code> 类似一个“定点分数”（fixed point fraction）。可以打开<a class="reference external" href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">浮点可视化工具</a>并输入 <code class="docutils literal notranslate"><span class="pre">0.1</span></code>，你会看到类似 <code class="docutils literal notranslate"><span class="pre">0xcccccccd</span></code> 的数字。该技术称为<strong>倒数乘法</strong>（reciprocal multiplication），在 GCC 中是一个常见的转换，其背后的数学原理可能复杂一些，感兴趣可以阅读 <a class="reference external" href="http://homepage.cs.uiowa.edu/~jones/bcd/divide.html">Reciprocal Multiplication</a> 在线教程。</p>
</section>
</section>
<section id="id10">
<h2>任务 3：运行时栈<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<section id="id11">
<h3>运行时栈机制<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>以下案例通过检查运行时栈的机制，练习使用一些新的 GDB 命令。</p>
<p>在编辑器中打开 <code class="docutils literal notranslate"><span class="pre">stack.c</span></code>，仔细阅读各个函数的 C 代码。在 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 下运行 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 程序。在 <code class="docutils literal notranslate"><span class="pre">kermit</span></code> 上设置断点，然后在 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 中 <code class="docutils literal notranslate"><span class="pre">run</span></code> 程序。在断点处停止时，设置下述自动显示表达式。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(gdb) display/3i $rip
(gdb) display/4gx $rsp
</pre></div>
</div>
<p>第一个意思是显示接下来要执行的 3 条汇编指令，命令可以读作“display the 3 <strong>i</strong>nstructions starting from <code class="docutils literal notranslate"><span class="pre">$rip</span></code>”。这将显示我们当前使用的指令，以及接下来出现的两条指令。显示格式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">=&gt;</span> <span class="mh">0x4011a5</span> <span class="o">&lt;</span><span class="n">kermit</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">push</span>   <span class="o">%</span><span class="n">rbp</span>
   <span class="mh">0x4011a6</span> <span class="o">&lt;</span><span class="n">kermit</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">push</span>   <span class="o">%</span><span class="n">rbx</span>
   <span class="mh">0x4011a7</span> <span class="o">&lt;</span><span class="n">kermit</span><span class="o">+</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">mov</span>    <span class="o">%</span><span class="n">edi</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>
</pre></div>
</div>
<p>第二个显示栈上前 4 个字的内容，命令可以读作“display the 4 <strong>g</strong>iant words (quadwords) in he<strong>x</strong> starting at <code class="docutils literal notranslate"><span class="pre">$rsp</span></code>”。显示格式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mh">0x7fffffffe3a8</span><span class="p">:</span> <span class="mh">0x00000000004011dc</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x7fffffffe3b8</span><span class="p">:</span> <span class="mh">0x00007ffff7db4d90</span>      <span class="mh">0x0000000000000000</span>
</pre></div>
</div>
<p>这将显示栈上前 4 个字的内容。栈顶是最低的内存地址，阅读顺序从栈顶到栈底，双列内容按照从左到右顺序。参考下面的“栈帧图”，其中栈的顶部（最低地址）位于底部：</p>
<div class="table-wrapper colwidths-auto docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>地址</p></th>
<th class="head"><p>内容</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">0x7fffffffe3c0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">0x7fffffffe3b8</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x00007ffff7db4d90</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">0x7fffffffe3b0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x0000000000000000</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">0x7fffffffe3a8</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0x00000000004011dc</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<p>现在使用 <code class="docutils literal notranslate"><span class="pre">stepi</span></code> 按汇编指令单步执行。遍历 <code class="docutils literal notranslate"><span class="pre">kermit</span></code> 函数，包括对 <code class="docutils literal notranslate"><span class="pre">dinky/binky</span></code> 的调用。观察控制是如何从主调函数转移到被调函数并返回的。自动显示可以显示栈上发生的情况以及 <code class="docutils literal notranslate"><span class="pre">$rip</span></code> 和 <code class="docutils literal notranslate"><span class="pre">$rsp</span></code> 是如何变化的。以下是一些特别需要注意的方面：</p>
<ul class="simple">
<li><p>在 <code class="docutils literal notranslate"><span class="pre">kermit</span></code> 函数开始时，它将 caller-owned 寄存器 <code class="docutils literal notranslate"><span class="pre">%rbp</span></code> 和 <code class="docutils literal notranslate"><span class="pre">%rbx</span></code> 中的值压到栈上，并在最后将它们弹出。<strong>这是因为被调函数必须确保 caller-owned 寄存器在调用前后保持相同</strong>。
例如，在这种情况下，<code class="docutils literal notranslate"><span class="pre">main</span></code>（或另一个调用者）也可能依赖于 <code class="docutils literal notranslate"><span class="pre">％rbp</span></code> 和 <code class="docutils literal notranslate"><span class="pre">％rbx</span></code>。因此，<code class="docutils literal notranslate"><span class="pre">kermit</span></code> 在返回之前必须将它们恢复到原来的状态。</p></li>
<li><p>如果寄存器是 callee-owned 被调函数本身所有，则不需要担心其内容被覆盖。<strong>被调函数没有必要在使用 callee-owned 寄存器之前保存其现有的值</strong>。但是，如果该函数本身又调用了另一个函数，则它可能需要将该寄存器的内容提前保存在某个地方，因为它的子函数可能会覆盖这些寄存器！
例如，如果 <code class="docutils literal notranslate"><span class="pre">main</span></code> 使用了 <code class="docutils literal notranslate"><span class="pre">%r10</span></code>（callee-owned），然后调用 <code class="docutils literal notranslate"><span class="pre">kermit</span></code>，则 <code class="docutils literal notranslate"><span class="pre">kermit</span></code> 也可以使用 <code class="docutils literal notranslate"><span class="pre">%r10</span></code>。因为 <code class="docutils literal notranslate"><span class="pre">kermit</span></code> 没有义务保留它，所以会覆盖 <code class="docutils literal notranslate"><span class="pre">main</span></code> 的值。</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">kermit</span></code> 中，哪条汇编指令负责设置 <code class="docutils literal notranslate"><span class="pre">binky</span></code> 的第二个参数？为什么没有设置第一个？<code class="docutils literal notranslate"><span class="pre">kermit</span></code> 必须将传递给它的参数（<code class="docutils literal notranslate"><span class="pre">%rdi</span></code>）保存在其他地方，因为 <code class="docutils literal notranslate"><span class="pre">binky</span></code> 也要使用 <code class="docutils literal notranslate"><span class="pre">%rdi</span></code> 记录参数。<code class="docutils literal notranslate"><span class="pre">kermit</span></code> 将其自己的第一个参数 <code class="docutils literal notranslate"><span class="pre">p</span></code> 复制到了哪里？</p></li>
<li><p>在调用 <code class="docutils literal notranslate"><span class="pre">binky</span></code> 之后，<code class="docutils literal notranslate"><span class="pre">kermit</span></code> 可以访问 <code class="docutils literal notranslate"><span class="pre">%eax</span></code> 中的返回值。然而，稍后它会调用 <code class="docutils literal notranslate"><span class="pre">dinky</span></code>，后者也会将返回值放入 <code class="docutils literal notranslate"><span class="pre">%eax</span></code> 中。<code class="docutils literal notranslate"><span class="pre">kermit</span></code> 将 <code class="docutils literal notranslate"><span class="pre">binky</span></code> 的返回值备份到了哪里？</p></li>
<li><p>在这两种情况下，看起来 <code class="docutils literal notranslate"><span class="pre">kermit</span></code> 都使用了 caller-owned 寄存器。为什么它必须使用 caller-owned 寄存器？为什么在这些情况下 callee-owned 寄存器不起作用？</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bigbird</span></code> 函数声明了一个相当长的局部变量列表。它声明的数组存储在栈上，但其他变量却存储在 callee-owned 寄存器中。为什么要这样处理？单步执行 <code class="docutils literal notranslate"><span class="pre">bigbird</span></code> 函数，并使用 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">locals</span></code> 查看每一步可以访问哪些变量。</p></li>
</ul>
<p>x86-64 只有少数几个寄存器，但是它们的需求量却很大；编译器努力确保最大限度地利用这些资源。参数和返回值使用寄存器传递/返回，局部变量也尽可能保存在寄存器中。编译器更倾向使用“暂存寄存器”（例如，callee-owned 寄存器），避免保存/恢复主调函数的数据。相反，如果使用 caller-owned 寄存器，则可能必须要这样做。</p>
</section>
<section id="id12">
<h3>函数间“通信”<a class="headerlink" href="#id12" title="Link to this heading">#</a></h3>
<p>程序 <code class="docutils literal notranslate"><span class="pre">channel</span></code> 的灵感来自于实验 3 中遇到的一个错误。问题代码一直可以“正常工作”，直到添加打印语句才会导致错误行为，而删除打印语句便能“修复”问题——非常诡异！</p>
<ul class="simple">
<li><p>查看 <code class="docutils literal notranslate"><span class="pre">channel.c</span></code> 中的代码。函数 <code class="docutils literal notranslate"><span class="pre">init_array</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sum_array</span></code> 各自声明一个栈数组。函数 <code class="docutils literal notranslate"><span class="pre">init_array</span></code> 设置数组值，而函数 <code class="docutils literal notranslate"><span class="pre">sum_array</span></code> 将数组值相加。两个函数都不带任何参数。编译器有一个关于 <code class="docutils literal notranslate"><span class="pre">sum_array</span></code> 的警告，它是什么？</p></li>
<li><p>程序调用 <code class="docutils literal notranslate"><span class="pre">init_array()</span></code> 然后调用 <code class="docutils literal notranslate"><span class="pre">sum_array()</span></code>。尽管两个调用之间没有显式的传递/返回，但数组似乎神奇地按预期进行了传递。这两个函数是如何通信的？（提示：当数据从栈中弹出时，它并不会被清除——只是增加 <code class="docutils literal notranslate"><span class="pre">%rsp</span></code> 来表明该内存区域可以重用）</p></li>
<li><p>程序第二次尝试将数组从 <code class="docutils literal notranslate"><span class="pre">init_array</span></code> “传递”到 <code class="docutils literal notranslate"><span class="pre">sum_array</span></code> 却失败了。这是为什么呢？</p></li>
</ul>
<p>对于实验 3 中的问题，这个练习是否提供了更多可能的解释？</p>
</section>
<section id="id13">
<h3>递归调用栈<a class="headerlink" href="#id13" title="Link to this heading">#</a></h3>
<p>CS101 讲解过的 <code class="docutils literal notranslate"><span class="pre">factorial</span></code> 程序是一个经典的递归阶乘函数。一起来回顾一下，并探究汇编级别的工作过程。</p>
<ul class="simple">
<li><p>运行 <code class="docutils literal notranslate"><span class="pre">./factorial</span> <span class="pre">5</span> <span class="pre">6</span> <span class="pre">7</span> <span class="pre">8</span> <span class="pre">9</span></code> 计算一些小阶乘，再尝试一些更大的值：<code class="docutils literal notranslate"><span class="pre">./factorial</span> <span class="pre">10</span> <span class="pre">11</span> <span class="pre">12</span> <span class="pre">13</span> <span class="pre">14</span> <span class="pre">15</span> <span class="pre">16</span></code>。似乎发生了一些可疑的事情。阶乘函数以惊人的速度增长——用不了多久就会溢出整数的范围！</p></li>
<li><p>查看 <code class="docutils literal notranslate"><span class="pre">factorial</span></code> 函数的代码，如果计算负数的阶乘，那么会发生什么？现在尝试一下：<code class="docutils literal notranslate"><span class="pre">./factorial</span> <span class="pre">-1</span></code>。这是否符合你的预期？无效的数字是如何导致内存问题的？尝试在 GDB 下运行参数 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 的阶乘。使用 <code class="docutils literal notranslate"><span class="pre">backtrace</span></code> 找出崩溃时程序正在执行的位置。这是否能说明问题所在？</p></li>
<li><p>进入 GDB 并计算出每个 <code class="docutils literal notranslate"><span class="pre">factorial</span></code> 栈帧的大小。这里有两种不同的策略；两者都可以尝试一下！</p>
<ul>
<li><p>反汇编 <code class="docutils literal notranslate"><span class="pre">factorial</span></code> 并扫描其指令。寻找那些更改 <code class="docutils literal notranslate"><span class="pre">%rsp</span></code> 的指令，因为这是栈增长和收缩的关键。每个 <code class="docutils literal notranslate"><span class="pre">pushq</span></code> 和 <code class="docutils literal notranslate"><span class="pre">callq</span></code> 指令都会将一个 8 字节值复制到栈并递减 <code class="docutils literal notranslate"><span class="pre">%rsp</span></code>。还可以显式移动 <code class="docutils literal notranslate"><span class="pre">%rsp</span></code> 来为局部变量或暂存结果腾出空间。注意，<code class="docutils literal notranslate"><span class="pre">factorial</span></code> 没有对 <code class="docutils literal notranslate"><span class="pre">%rsp</span></code> 进行额外调整。存储在其帧中的唯一数据是通过 <code class="docutils literal notranslate"><span class="pre">pushq</span></code> 和 <code class="docutils literal notranslate"><span class="pre">callq</span></code> 指令保存的寄存器。统计 <code class="docutils literal notranslate"><span class="pre">factorial</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">pushq</span></code> 和 <code class="docutils literal notranslate"><span class="pre">callq</span></code> 指令，然后乘以 8 就能得到每个栈帧使用的总字节数。</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">factorial</span></code> 上设置断点，并执行几次调用，然后使用命令 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">frame</span> <span class="pre">1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">frame</span> <span class="pre">2</span></code> 检查顶部的两个栈帧。查找标记为 <code class="docutils literal notranslate"><span class="pre">Stack</span> <span class="pre">frame</span> <span class="pre">at</span></code> 的帧地址，并将两者相减就可以计算出单个帧的大小。</p></li>
<li><p>这两种方法应该都能得到相同的答案。注意内存地址是十六进制表示的。</p></li>
</ul>
</li>
<li><p>在服务器上，程序启动时默认配置的栈内存是一个固定值，并且不能超出该限制。使用 Linux 命令 <code class="docutils literal notranslate"><span class="pre">ulimit</span> <span class="pre">-a</span></code> 可以查看进程的各种限制。由此可见，默认的栈内存大小是多少？</p></li>
<li><p>将栈内存的限制除以 <code class="docutils literal notranslate"><span class="pre">factorial</span></code> 栈帧的大小，可以估算出递归调用的最大栈深度。再次在 GDB 下运行参数 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 的阶乘。当程序崩溃时，使用 <code class="docutils literal notranslate"><span class="pre">backtrace</span> <span class="pre">-10</span></code> 查看栈顶，确定栈的深度。该深度和你估计的值是否接近？（检查的时间较长，结束后使用 <code class="docutils literal notranslate"><span class="pre">Ctrl+z</span></code> 退出 GDB）</p></li>
<li><p>编辑 <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>，修改程序的优化级别。找到 <code class="docutils literal notranslate"><span class="pre">factorial:</span> <span class="pre">CFLAGS</span> <span class="pre">+=</span> <span class="pre">-Og</span></code> 的行。当前设置为 <code class="docutils literal notranslate"><span class="pre">-Og</span></code>，这是一个相对适中的优化级别，方便使用 GDB 进行调试。将 <code class="docutils literal notranslate"><span class="pre">-Og</span></code> 更改为 <code class="docutils literal notranslate"><span class="pre">-O2</span></code> 进行更高级别的优化。执行 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">clean</span> <span class="pre">&amp;&amp;</span> <span class="pre">make</span></code>，然后再次运行 <code class="docutils literal notranslate"><span class="pre">./factorial</span> <span class="pre">-1</span></code>。哇！发生了什么？编译器是否“修复”了无限递归？反汇编优化后的 <code class="docutils literal notranslate"><span class="pre">factorial</span></code>，看看编译器对代码执行了什么操作。这种奇特的优化称为“<a class="reference external" href="http://en.wikipedia.org/wiki/Tail_recursion">尾递归消除</a>”。（注意，开启更高级别的优化后，可能造成 GDB 无法正常工作）</p></li>
</ul>
</section>
</section>
<section id="id14">
<h2>任务 4：调试运行时栈的问题<a class="headerlink" href="#id14" title="Link to this heading">#</a></h2>
<p>当函数在其内部发生错误时会发生什么？其表现的症状又是什么？我们如何调试此类错误？一起来研究一些示例程序，理解这些内容对识别作业 5 中的漏洞至关重要！</p>
<section id="id15">
<h3>内存踩踏<a class="headerlink" href="#id15" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">buggy.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">clear_array</span></code> 函数有个循环范围错误。这是一个很常见的错误，特别是对于不习惯 C 数组从零开始索引的程序员。在这个案例中，这个错误产生了令人惊讶的后果。</p>
<ul class="simple">
<li><p>在尝试执行该程序之前，首先推测一下期望结果是什么？</p></li>
<li><p>运行程序。它似乎永远不会完成。</p></li>
<li><p>在 GDB 下运行。使用 <code class="docutils literal notranslate"><span class="pre">Ctl-C</span></code> 中断程序并查看它正在执行的位置。继续执行程序，然后再次中断。现在执行到了哪里？</p></li>
<li><p>再次中断，然后从这里单步执行。为什么循环花了这么长的时间？<code class="docutils literal notranslate"><span class="pre">i</span></code> 的值到底发生了什么？</p></li>
</ul>
<p>剧透：<code class="docutils literal notranslate"><span class="pre">i</span></code> 的值由于代码非正常赋值而发生变化。这类错误被称为内存“踩踏（stomping）”或内存“破坏（clobbering）”。相邻区域的溢出、使用指向已释放的栈内存指针、引用已释放的堆内存指针或使用未初始化的指针，变量都可能会被“踩踏”。这类错误很难调试，因为变量没有出现在影响其值的代码中，此外，踩踏可能要等程序运行很久以后才会被注意到，因而很难将二者因果关系进行联系。尽管 Valgrind 非常擅长检测无效地址写入的错误，但它无法检测这些<strong>出于意外原因写入有效地址</strong>的情况。我们需要另一种策略或工具来发现这种错误。</p>
<p>一起来学习如何使用 GDB 中的 <code class="docutils literal notranslate"><span class="pre">watch</span></code> 命令，该命令用于监视给定的表达式或内存位置。 GDB 可以设置一种特殊类型的断点，只要该表达式的值发生改变或对该内存位置进行写入操作，该断点就会停止执行你的程序。这里有些例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">watch</span> <span class="n">myvar</span>           <span class="o">//</span> <span class="n">report</span> <span class="n">when</span> <span class="n">myvar</span> <span class="n">changes</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">watch</span> <span class="o">*</span><span class="mh">0x608502</span>       <span class="o">//</span> <span class="n">report</span> <span class="k">if</span> <span class="n">write</span> <span class="n">to</span> <span class="n">memory</span> <span class="n">location</span>
</pre></div>
</div>
<ul class="simple">
<li><p>在 GDB 下运行程序，在第 7 行上设置断点，一旦命中该断点，设置一个观察点（watchpoint）来监视 <code class="docutils literal notranslate"><span class="pre">i</span></code> 的变化。</p></li>
<li><p>也可以添加一个 <code class="docutils literal notranslate"><span class="pre">display</span></code> 命令来显示汇编指令。还记得怎么做吗？</p></li>
<li><p>继续运行程序，GDB 将在每次对 <code class="docutils literal notranslate"><span class="pre">i</span></code> 进行更改时停止。观察点会提醒你循环中计数器每次的增量：从 0 到 1、1 到 2 等等，同时也会显示 <code class="docutils literal notranslate"><span class="pre">i</span></code> 被踩踏时的值。</p></li>
<li><p>当 <code class="docutils literal notranslate"><span class="pre">i</span></code> 从 2 变为 3 时，在 GDB 中执行 <code class="docutils literal notranslate"><span class="pre">disassemble</span></code>，查看此时哪个汇编指令负责修改 <code class="docutils literal notranslate"><span class="pre">i</span></code>。提示，<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> 指向即将执行的指令，因此更改 <code class="docutils literal notranslate"><span class="pre">i</span></code> 的指令位于该指令之前。C 代码中这条指令来自哪里？</p></li>
<li><p>当 <code class="docutils literal notranslate"><span class="pre">i</span></code> 从 5 变为 0 时，在 GDB 中再次执行 <code class="docutils literal notranslate"><span class="pre">disassemble</span></code>，查看此时哪个汇编指令负责修改 <code class="docutils literal notranslate"><span class="pre">i</span></code>。这和上述更改 <code class="docutils literal notranslate"><span class="pre">i</span></code> 的指令并不相同。此时的指令是什么？C 代码中这条指令来自哪里？什么代码破坏了 <code class="docutils literal notranslate"><span class="pre">i</span></code> 的值？</p></li>
</ul>
<p>设置观察点是一个很有用的调试手段，可以用于追踪那些对内存进行神秘操作的错误（在二进制炸弹中可能也非常有用…）</p>
</section>
<section id="id16">
<h3>栈溢出<a class="headerlink" href="#id16" title="Link to this heading">#</a></h3>
<p>C 标准库函数 <code class="docutils literal notranslate"><span class="pre">gets</span></code> 的设计非常糟糕。它的目的是从 <code class="docutils literal notranslate"><span class="pre">stdin</span></code> 读取一行文本，在第一个换行符处停止，并将读取的字符写入客户端的缓冲区。<code class="docutils literal notranslate"><span class="pre">gets</span></code> 的致命缺陷是，它唯一的参数是缓冲区的起始地址，而没有指示该缓冲区的长度。如果没有长度，<code class="docutils literal notranslate"><span class="pre">gets</span></code> 就无法判断何时应该停止写入，从而发生缓冲区溢出问题。没有绝对的办法，可以安全地使用 <code class="docutils literal notranslate"><span class="pre">gets</span></code>。它的使用早已被弃用，取而代之的是 <code class="docutils literal notranslate"><span class="pre">fgets</span></code> 函数（增加了约束参数），但出于向后兼容性的原因，它在标准库中依然存在。</p>
<ul class="simple">
<li><p>首先阅读 <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">gets</span></code> 的 <code class="docutils literal notranslate"><span class="pre">BUGS</span></code> 部分，了解针对该函数的安全问题提示。当你编译 <code class="docutils literal notranslate"><span class="pre">smash</span></code> 程序时，编译器和链接器将会发出各种警告，这些警告试图进一步阻止你使用 <code class="docutils literal notranslate"><span class="pre">gets</span></code>。让我们观察一下，如果忽略警告并继续使用该函数会产生什么后果。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">smash.c</span></code> 程序调用 <code class="docutils literal notranslate"><span class="pre">gets</span></code> 将用户的输入读取到大小为 12 的缓冲区中。任何长度超过 12 的输入都将发生栈溢出。溢出的后果无法估量，具体取决于写入了多少字节。</p>
<ul class="simple">
<li><p>运行 <code class="docutils literal notranslate"><span class="pre">smash</span></code> 程序，当提示输入你的名字时，输入“stickmind”。这个名字没有超出 12 个字节，所以没有问题。再次输入“stickmind cs102”，稍微长一点是否可以？继续输入更长的字符串，最终我们的程序将会崩溃。在 GDB 下运行该程序并输入相同长度名称。在程序崩溃时，使用 <code class="docutils literal notranslate"><span class="pre">backtrace</span></code>。哇哦，栈内存到底发生了什么？让我们看看能否解决这个问题。</p></li>
<li><p>反汇编 <code class="docutils literal notranslate"><span class="pre">greet</span></code> 函数并尝试画出它的栈帧图。请务必注意缓冲区的位置及其与相邻数据的关系。你可以通过查看汇编指令并跟踪它们如何操作栈内存来获取此信息。</p></li>
<li><p>对于任何长度超过 12 的输入，<code class="docutils literal notranslate"><span class="pre">gets</span></code> 读取的字符都将溢出缓冲区。缓冲区的直接邻居是什么？为什么这个关键数据一旦被覆盖就会导致程序崩溃呢？多长的输入才能破坏这个关键数据？如果输入仅溢出 1 个字节是什么情况？2 个字节、4 个字节、甚至更长字节呢？</p></li>
<li><p>数据溢出时不会立刻发生崩溃；只有在损坏某些数据时，才可能出现问题。找出 <code class="docutils literal notranslate"><span class="pre">greet</span></code> 函数中引发崩溃的汇编指令，并解释该指令具体做了什么。</p></li>
<li><p>接下来使用管道输入一个特殊的字符串：<code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">-e</span> <span class="pre">'Hello!</span> <span class="pre">Welcome</span> <span class="pre">to</span> <span class="pre">pluto!\0141\0022\0100'</span> <span class="pre">|</span> <span class="pre">./smash</span></code>。冥王星？我们怎么到那里了？程序没有任何一个地方调用了函数 <code class="docutils literal notranslate"><span class="pre">pluto</span></code>，这个结果太让人意外了！仔细检查调用栈帧，看看你能否搞清楚其中的原因。当 <code class="docutils literal notranslate"><span class="pre">greet</span></code> 完成时，它没有恢复 <code class="docutils literal notranslate"><span class="pre">main</span></code> 中的指令，而是调用了 <code class="docutils literal notranslate"><span class="pre">pluto</span></code> 函数。<code class="docutils literal notranslate"><span class="pre">main</span></code> 中待恢复的指令地址是什么？该地址是如何变成 <code class="docutils literal notranslate"><span class="pre">pluto</span></code> 函数的地址的？</p></li>
</ul>
<p><strong>推荐阅读</strong>：Peter van der Linden 的《C 专家编程》总结了早期的 Internet 蠕虫病毒是如何利用 <code class="docutils literal notranslate"><span class="pre">gets</span></code> 的漏洞来执行攻击的。此书还包含大量引人入胜的信息，对 C 语言的学习有着很好的启发和洞察——强烈推荐！</p>
</section>
</section>
<section id="id17">
<h2>任务 5：汇编视角下的函数指针<a class="headerlink" href="#id17" title="Link to this heading">#</a></h2>
<p>最后一个汇编相关的细节可能对下一个作业有帮助，那就是<strong>函数指针是如何工作的</strong>。你可以使用一个带有操作数的 <code class="docutils literal notranslate"><span class="pre">jmp</span></code> 或 <code class="docutils literal notranslate"><span class="pre">call</span></code> 指令，该操作数可以是要跳转的标签（在指令中进行硬编码），也可以是要跳转的地址。例如，如果函数地址存储在 <code class="docutils literal notranslate"><span class="pre">%rax</span></code> 中，那么我们可以使用 <code class="docutils literal notranslate"><span class="pre">jmp</span> <span class="pre">*%rax</span></code> 或 <code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">*%rax</span></code> 来跳转或调用该函数。这是因为函数指针本质上只是<strong>函数第一条指令所在的地址</strong>。</p>
<ul class="simple">
<li><p>查看 <code class="docutils literal notranslate"><span class="pre">function_pointers.c</span></code> 文件，该文件包含一个泛型函数 <code class="docutils literal notranslate"><span class="pre">gfind_max</span></code> 以及一些相关的代码.</p></li>
<li><p>单步执行 <code class="docutils literal notranslate"><span class="pre">gfindmax</span></code> 函数的汇编指令，找出调用 <code class="docutils literal notranslate"><span class="pre">compare_function</span></code> 的位置。哪条汇编指令执行了函数指针的调用？</p></li>
<li><p>打印出 <code class="docutils literal notranslate"><span class="pre">compare_function</span></code> 参数的值。然后在 <code class="docutils literal notranslate"><span class="pre">cmp_alpha</span></code> 函数的开头设置一个断点，继续执行程序，直到命中该断点为止。接下来，打印出 <code class="docutils literal notranslate"><span class="pre">%rip</span></code> 寄存器的值。这两种方法是否都打印出了相同的值？</p></li>
</ul>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../assign_5/index.html">
              <div class="page-info">
                <div class="context">
                  <span>下一页</span>
                </div>
                <div class="title">作业 5：来一点汇编</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../asm_tools/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>上一页</span>
                </div>
                
                <div class="title">汇编工具</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, <a href='https://www.stickmind.com/' target="_blank">StickMind</a>
            </div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            本页目录
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">实验 5：汇编和运行时栈</a><ul>
<li><a class="reference internal" href="#id2">学习目标</a></li>
<li><a class="reference internal" href="#id3">初始代码</a></li>
<li><a class="reference internal" href="#gdb">任务 1：GDB 调试汇编</a></li>
<li><a class="reference internal" href="#id4">任务 2：汇编指令练习</a><ul>
<li><a class="reference internal" href="#id5">移动和地址模式</a></li>
<li><a class="reference internal" href="#id6">整型算术运算</a></li>
<li><a class="reference internal" href="#id7">加载有效地址</a></li>
<li><a class="reference internal" href="#id8">乘法运算</a></li>
<li><a class="reference internal" href="#id9">除法运算</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">任务 3：运行时栈</a><ul>
<li><a class="reference internal" href="#id11">运行时栈机制</a></li>
<li><a class="reference internal" href="#id12">函数间“通信”</a></li>
<li><a class="reference internal" href="#id13">递归调用栈</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id14">任务 4：调试运行时栈的问题</a><ul>
<li><a class="reference internal" href="#id15">内存踩踏</a></li>
<li><a class="reference internal" href="#id16">栈溢出</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17">任务 5：汇编视角下的函数指针</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=7d86a446"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/tabs.js?v=3ee01567"></script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    </body>
</html>