<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="next" title="作业 2. C 字符串" href="../assign_2/index.html" /><link rel="prev" title="函数参数" href="../function_paremeters/index.html" />

    
    <link rel="shortcut icon" href="_static/favicon.ico"/>
        <title>实验 2. 数组和指针 - CS102 文档</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../../_static/pied-piper-admonition.css?v=e32e2275" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<div class="announcement">
  <aside class="announcement-content">
     路漫漫其修远兮，吾将上下而求索 
  </aside>
</div>

<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">CS102 文档</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">CS102 文档</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_0.html">开发环境</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 开发环境</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_0/linux_intro/index.html">Linux 介绍</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Linux 介绍</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/linux_intro/linux_on_windows.html">Windows MSYS2 环境</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/linux_intro/linux_virtual_box.html">Ubuntu 虚拟机</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_0/command_line/linux_command.html">Linux 命令行</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Linux 命令行</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/command_line/basic.html">基本命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/command_line/file_operation.html">文件操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/command_line/searching.html">文件搜索</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_0/from_cxx_to_c/from_cxx_to_c.html">从 C++ 到 C</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of 从 C++ 到 C</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/from_cxx_to_c/simpio.html">simpio.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/from_cxx_to_c/strlib.html">strlib.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/from_cxx_to_c/pig_latin.html">Pig Latin</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_0/lab_0/index.html">实验 0：上手 Linux 开发环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_0/assign_0/index.html">作业 0：使用 Linux 和 C</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_1.html">数据的表示</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 数据的表示</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/bit_byte/index.html">位、字节和进制</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_1/int_representation/index.html">整数的表示</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of 整数的表示</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_1/int_representation/index2.html">整型溢出和转换</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/bit_level_ops/index.html">位运算及其应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/lab_1/index.html">实验 1. 数据的表示</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/assign_1/index.html">作业 1. 有趣的位</a></li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../topic_2.html">数组和指针</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of 数组和指针</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 has-children"><a class="reference internal" href="../string/index.html">字符串</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of 字符串</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../string/string.html">字符串表示</a></li>
<li class="toctree-l3"><a class="reference internal" href="../string/string-h.html">string.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../string/char-star.html">字符串指针</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../array_and_pointer/index.html">数组和指针</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of 数组和指针</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../array_and_pointer/star-pointer.html">理解 <code class="docutils literal notranslate"><span class="pre">*p</span></code> 的特殊性</a></li>
<li class="toctree-l3"><a class="reference internal" href="../array_and_pointer/array_and_pointer_ops.html">数组索引和指针运算</a></li>
<li class="toctree-l3"><a class="reference internal" href="../array_and_pointer/array_and_pointer_mis.html">多维数组和二级指针</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../function_paremeters/index.html">函数参数</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">实验 2. 数组和指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="../assign_2/index.html">作业 2. C 字符串</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_3.html">栈和堆</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of 栈和堆</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../topic_3/memory_layout/index.html">内存布局</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_3/memeory_management/index.html">内存管理</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_3/struct/index.html">结构体</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of 结构体</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_3/struct/stack_adt.html">设计栈抽象数据类型</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_3/lab_3/index.html">实验 3：栈和堆</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_3/assign_3/index.html">作业 3：有趣的堆</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_4.html">泛型编程</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of 泛型编程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../topic_4/void_pointer/index.html">泛型指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_4/function_pointer/index.html">函数指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_4/lab_4/index.html">实验 4：泛型和回调</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_4/assign_4/index.html">作业 4：深入泛型指针</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_5.html">汇编语言</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle navigation of 汇编语言</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_5/asm_intro/index.html">汇编概述</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle navigation of 汇编概述</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_5/asm_intro/index2.html">程序员视角下的硬件</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_5/x86-64_asm/index.html">x86-64 指令</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle navigation of x86-64 指令</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_5/x86-64_asm/data_move.html">数据传送指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_5/x86-64_asm/arithmetic_and_logic.html">算术与逻辑指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_5/x86-64_asm/control.html">控制指令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_5/procedure/index.html">过程：函数调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_5/asm_tools/index.html">汇编工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_5/lab_5/index.html">实验 5：汇编和运行时栈</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_5/assign_5/index.html">作业 5：来一点汇编</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_6.html">堆分配器</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><div class="visually-hidden">Toggle navigation of 堆分配器</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../topic_6/lab_6/index.html">实验 6. 优化和分析</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>返回顶部</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>实验 2. 数组和指针<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<p>话题 2 开始接触标准库——封装好的标准函数集合。<a class="reference external" href="https://web.stanford.edu/class/archive/cs/cs107/cs107.1206/guide/stdlib">Guide to C stdlib functions</a> 针对 C 标准库中可用的函数提供了一份很好的概述。</p>
<p>许多程序员只是将标准库看作一个“黑匣子”——按文档说明使用函数，但对底层的实现并不清楚。鉴于本课程的目标是让大家<strong>真正了解系统的内部运作方式</strong>，所以我们将进行更深入的研究。</p>
<p>为此，我们提供了一些练习，深入研究标准库的代码。通过研究工业级代码，并反思其在设计、可读性和效率之间的权衡，我们可以学到很多东西。深入了解这些函数的底层实现，我们还可以更好地使用这些函数，并避免一些陷阱和误用。</p>
<p>这些知识也可能会激发你写出自己的 <code class="docutils literal notranslate"><span class="pre">isdigit</span></code> 或 <code class="docutils literal notranslate"><span class="pre">strncpy</span></code> 函数，并集成到你的程序中，但最佳实践是<strong>尽可能选择标准库函数</strong>。这些函数已经编写完成，并且经过了充分的调试和验证——有什么理由不去使用它们呢？我们从代码中学习这些函数的实现，对一些不好的设计提出自己的见解和批评，但在以后使用它们时，也应该心存感激。</p>
<p>本次实验进一步练习使用 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Valgrind</span></code>、学习 <code class="docutils literal notranslate"><span class="pre">string.h</span></code> 接口以及将 C 字符串作为原始数组/指针进行操作。以下一些问题用于检测你的理解，并让你进一步思考这些概念：</p>
<ul class="simple">
<li><p>对 <code class="docutils literal notranslate"><span class="pre">strncpy</span></code> 的调用，在什么情况下会以空字符 <code class="docutils literal notranslate"><span class="pre">NUL</span></code>（<code class="docutils literal notranslate"><span class="pre">\0</span></code>）作为目标字符串的结尾，在什么情况下不会？使用未以 <code class="docutils literal notranslate"><span class="pre">NUL</span></code> 字符结尾的字符串会产生哪些后果？</p></li>
<li><p>一个程序直接运行时看起来没什么问题，但是在 <code class="docutils literal notranslate"><span class="pre">Valgrind</span></code> 下运行时，它会报告错误。你的伙伴认为 <code class="docutils literal notranslate"><span class="pre">Valgrind</span></code> 的报告大错特错，而且非常偏执地认为程序运行正常就说明没有问题。向他们解释为什么访问不属于你的内存时会造成问题，并进一步描述即便发生了错误，为什么内存错误可以无症状地潜伏在程序中。</p></li>
<li><p>编写一个 C 表达式判断给定的 <code class="docutils literal notranslate"><span class="pre">char*</span></code> 是否包含 <code class="docutils literal notranslate"><span class="pre">N</span></code> 个字符长的前缀/后缀。请务必利用 <code class="docutils literal notranslate"><span class="pre">string.h</span></code> 库函数。如果使用比字符串长度更长的 <code class="docutils literal notranslate"><span class="pre">N</span></code> 值来计算表达式，会发生什么情况？</p></li>
<li><p>函数 <code class="docutils literal notranslate"><span class="pre">atoi/strtol</span></code> 将数字字符串转换为十进制数字，但没有标准函数可以反向转换。描述一种可用于将数字转换为等效字符串的技术。</p></li>
</ul>
<section id="id2">
<h2>学习目标<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>研究数组和指针在 C 中如何工作</p></li>
<li><p>阅读并分析操作 C 字符和字符串的代码</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Valgrind</span></code> 检测和调试内存错误</p></li>
</ul>
</section>
<section id="id3">
<h2>初始代码<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>你的个人用户目录下应该已经有 <code class="docutils literal notranslate"><span class="pre">cs102</span></code> 这个文件夹了，通过下面的命令拷贝初始代码到该目录中：</p>
<div class="highlight-Shell notranslate"><div class="highlight"><pre><span></span>cp<span class="w"> </span>-r<span class="w"> </span>/home/cs102-shared/labs/lab2<span class="w"> </span>~/cs102
</pre></div>
</div>
</section>
<section id="gdb">
<h2>任务 1：GDB 探究指针和数组<a class="headerlink" href="#gdb" title="Link to this heading">#</a></h2>
<p>首先，我们将研究指针和数组语法以及两者之间的异同。为此，我们将使用 <code class="docutils literal notranslate"><span class="pre">code.c</span></code> 程序，这个示例程序展示了数组和指针的各种行为。</p>
<p>构建程序，在 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 下启动它，并在 <code class="docutils literal notranslate"><span class="pre">main</span></code> 处设置断点。当程序在断点处停止时，使用 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">locals</span></code> 查看未初始化的栈变量状态。该命令列出当前函数中所有局部变量的值。单步执行初始化语句并再次使用 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">locals</span></code>。注意，当 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 报告执行在第 N 行时，第 N 行尚未执行。</p>
<p>下面表达式都引用了局部变量 <code class="docutils literal notranslate"><span class="pre">arr</span></code>。对于每个表达式，先尝试弄清楚该表达式的结果是什么，然后在 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 中验证你的理解是否正确。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">main</span></code> 将 <code class="docutils literal notranslate"><span class="pre">ptr</span></code> 初始化为 <code class="docutils literal notranslate"><span class="pre">arr</span></code>。栈上的数组名和指向该数组的指针几乎可以互换，但又不完全可以互换。尝试用 <code class="docutils literal notranslate"><span class="pre">ptr</span></code> 替换 <code class="docutils literal notranslate"><span class="pre">arr</span></code> 重新计算上述表达式。前五个表达式的计算结果相同，但后两个表达式的结果却不同。数组大小是多少？指针的大小又是多少？最后一个表达式是最难理解的。为什么可以给 <code class="docutils literal notranslate"><span class="pre">ptr</span></code> 赋值，但不能给 <code class="docutils literal notranslate"><span class="pre">arr</span></code> 赋值？</p>
<p>执行 <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">ptr</span> <span class="pre">=</span> <span class="pre">ptr</span> <span class="pre">-</span> <span class="pre">1</span></code> 将 <code class="docutils literal notranslate"><span class="pre">ptr</span></code> 重置为其原始值。使用 <code class="docutils literal notranslate"><span class="pre">step</span></code> 命令进入 <code class="docutils literal notranslate"><span class="pre">binky(arr,</span> <span class="pre">ptr)</span></code> 调用栈。 <code class="docutils literal notranslate"><span class="pre">step</span></code> 与 <code class="docutils literal notranslate"><span class="pre">next</span></code> 类似，但它不是执行整行并移至下一行，而是进入当前执行的行。进入 <code class="docutils literal notranslate"><span class="pre">binky</span></code> 后，使用 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">args</span></code> 查看两个参数的值。利用变量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code>，打印你能想到的任何表达式，它们将得出相同的结果。对于上面最后两个表达式：<code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 报告 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code> 的大小相同，并且两者都允许赋值。参数传递过程中发生了什么情况才能实现这一点？尝试画出内存示意图来阐明这个问题。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">change_char</span></code> 上设置断点并使用命令 <code class="docutils literal notranslate"><span class="pre">continue</span></code> 继续执行。当 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 在断点处停止时，使用 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">args</span></code> 可以查看当前函数栈 <code class="docutils literal notranslate"><span class="pre">change_char</span></code> 的参数。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">backtrace</span></code> 可以查看当前位置的函数调用栈帧列表。使用 <code class="docutils literal notranslate"><span class="pre">frame</span></code> 命令可以选择不同的栈帧。在 <code class="docutils literal notranslate"><span class="pre">backtrace</span></code> 命令的输出中，函数栈帧由内到外从 0 开始编号。尝试使用命令 <code class="docutils literal notranslate"><span class="pre">frame</span> <span class="pre">1</span></code> 来选择 <code class="docutils literal notranslate"><span class="pre">change_char</span></code> 的上一层栈帧，然后使用 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">locals</span></code> 来查看 <code class="docutils literal notranslate"><span class="pre">winky</span></code> 的状态。也可以使用简写命令，<code class="docutils literal notranslate"><span class="pre">up</span></code> 可以进入上一层栈帧，<code class="docutils literal notranslate"><span class="pre">down</span></code> 可以进入下一层栈帧。最后，执行 <code class="docutils literal notranslate"><span class="pre">frame</span> <span class="pre">0</span></code> 返回到调试器停止的位置。</p>
<p>单步执行 <code class="docutils literal notranslate"><span class="pre">change_char</span></code> 并检查每行之前和之后的状态。使用 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">args</span></code> 查看当前栈帧的参数，然后使用 <code class="docutils literal notranslate"><span class="pre">up</span></code> 和 <code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">locals</span></code> 查看上一层栈帧中变量发生的变化。仔细观察每条赋值语句的效果。</p>
<p>单步执行 <code class="docutils literal notranslate"><span class="pre">change_ptr</span></code> 并进行相同的观察。哪些赋值语句对 <code class="docutils literal notranslate"><span class="pre">winky</span></code> 具有持久效果，哪些没有？你能解释为什么吗？</p>
</section>
<section id="atoi">
<h2>任务 2：探究 atoi<a class="headerlink" href="#atoi" title="Link to this heading">#</a></h2>
<p>在作业 0 中，我们使用 <code class="docutils literal notranslate"><span class="pre">atoi</span></code> 函数将字符串参数转换为整数，该函数名来自 <strong>ascii to integer</strong> 的首字母。正如你在作业 0 中了解到的那样，<code class="docutils literal notranslate"><span class="pre">atoi</span></code> 使用起来非常方便，但却容易出错。在实际项目中，基本都被 <code class="docutils literal notranslate"><span class="pre">strtol</span></code> 函数取代了。本次作业就会迁移到这个新函数。函数 <code class="docutils literal notranslate"><span class="pre">strtol</span></code> 提供了更多的功能，但使用起来也更复杂。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">atoi.c</span></code> 程序中包含了一份 <code class="docutils literal notranslate"><span class="pre">atoi</span></code> 的实现，该实现改编自 <a class="reference external" href="https://musl.libc.org/">musl</a> 库。你可以先编译并运行它。请注意，该程序的代码风格并不全都值得你效仿——我们的目的仅仅是通过此份代码理解该函数底层的实现逻辑。</p>
<p>以下列出的一些问题，用于引导你阅读 <code class="docutils literal notranslate"><span class="pre">musl_atoi</span></code> 的代码：</p>
<ul class="simple">
<li><p>第 13 行：表达式 <code class="docutils literal notranslate"><span class="pre">*s</span></code> 计算后的值是什么？该表达式的另一种替代写法是什么？（或许替代的写法可读性更好……）</p></li>
<li><p>第 14 行：表达式 <code class="docutils literal notranslate"><span class="pre">s++</span></code> 对 <code class="docutils literal notranslate"><span class="pre">s</span></code> 做了什么？</p></li>
<li><p>第 17~23 行：如果字符串以减号 <code class="docutils literal notranslate"><span class="pre">-</span></code> 字符开头，那么哪行代码会让 <code class="docutils literal notranslate"><span class="pre">s</span></code> 跳过该字符？这很微妙！（<code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句的 <code class="docutils literal notranslate"><span class="pre">fallthrough</span></code> 行为可能会令人非常惊讶，并且通常是由异常触发的，所以对于故意不写 <code class="docutils literal notranslate"><span class="pre">break</span></code> 语句的地方，最好能写清楚注释，但是……）</p></li>
<li><p>该代码有两处针对字符串的循环遍历，但却都没有使用 <code class="docutils literal notranslate"><span class="pre">NUL</span></code> 终止字符进行显式测试。为什么这样的测试是没必要的？</p></li>
<li><p>如何将单个数字字符转换为对应的数值？该值又如何与目前为止所构建的值进行结合？</p></li>
<li><p>第 28 行：关于 <code class="docutils literal notranslate"><span class="pre">s++</span></code> 的一个奇怪现象是，该表达式不仅修改 <code class="docutils literal notranslate"><span class="pre">s</span></code>，还会计算出 <code class="docutils literal notranslate"><span class="pre">s</span></code> 的原始值。关于该行为，推荐阅读 <a class="reference external" href="https://stackoverflow.com/questions/7031326/what-is-the-difference-between-prefix-and-postfix-operators">Stack Overflow</a> 上的问题。换句话说，<code class="docutils literal notranslate"><span class="pre">s++</span></code> 会将 <code class="docutils literal notranslate"><span class="pre">s</span></code> 进行自增操作，但表达式的值不是自增后的值，而是原来的值。代码是如何利用该特性让字符串处理更简洁的？</p></li>
<li><p>第 25~31 行：该循环先将 <code class="docutils literal notranslate"><span class="pre">number</span></code> 建立为负值，然后再将其取负。注释表明这个决定可以避免在 <code class="docutils literal notranslate"><span class="pre">INT_MIN</span></code> 处发生溢出。为什么有必要将 <code class="docutils literal notranslate"><span class="pre">INT_MIN</span></code> 作为特殊情况？为什么程序将 <code class="docutils literal notranslate"><span class="pre">number</span></code> 构造为负数而不是正数？</p></li>
<li><p>当输入字符串包含非数字字符时会发生什么？如果该非数字字符是第一个字符又将如何？</p></li>
<li><p>第 31 行：三元表达式使用“<code class="docutils literal notranslate"><span class="pre">CONDITION</span> <span class="pre">?</span> <span class="pre">IF_TRUE</span> <span class="pre">:</span> <span class="pre">IF_FALSE</span></code>”的形式进行计算。尝试解释 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句。</p></li>
</ul>
<p>接下来编译 <code class="docutils literal notranslate"><span class="pre">atoi</span></code> 程序并做一些测试。选择一些感兴趣的输入，首先手动跟踪函数将如何处理，然后在 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 中逐步执行程序来验证你的理解是否正确。尝试一些可以成功转换的输入，例如 <code class="docutils literal notranslate"><span class="pre">./atoi</span> <span class="pre">107</span> <span class="pre">0</span> <span class="pre">-12</span></code>，然​​后再尝试一些有问题或格式错误的输入，例如 <code class="docutils literal notranslate"><span class="pre">./atoi</span> <span class="pre">3.14</span> <span class="pre">binky</span> <span class="pre">&#64;55</span> <span class="pre">--8</span></code>。如果输入超出整数可以表示的范围，结果将会如何？溢出？饱和？返回 0？引发错误？还是完全执行其他操作？</p>
</section>
<section id="valgrind">
<h2>任务 3：使用 Valgrind<a class="headerlink" href="#valgrind" title="Link to this heading">#</a></h2>
<p>每个实验室都会花一些时间来练习工具的使用。上周，是 <code class="docutils literal notranslate"><span class="pre">sanitycheck</span></code> 和 <code class="docutils literal notranslate"><span class="pre">gdb</span></code>。本周，我们介绍 Valgrind。</p>
<p>从现在开始，我们将大量使用指针，我们的程序出现内存错误的风险也将变得更大。这些错误很难追踪，此时学习 Valgrind 工具将很有必要。 Valgrind 是一个帮助检测内存错误的工具。<a class="reference external" href="https://web.stanford.edu/class/archive/cs/cs107/cs107.1206/resources/valgrind">Valgrind Memcheck</a> 是关于 Valgrind 的一份很好的指南。</p>
<p>下面让我们尝试使用 Valgrind 来修复程序。</p>
<ul class="simple">
<li><p>阅读 <code class="docutils literal notranslate"><span class="pre">buggy.c</span></code> 中的代码，查看两个植入的内存错误。我们从错误 1 开始。</p></li>
<li><p>运行 <code class="docutils literal notranslate"><span class="pre">./buggy</span> <span class="pre">1</span></code>，你应该可以看到 <strong>Segmentation fault (core dumped)</strong>。段错误是由于尝试读/写无法访问/无效的地址而导致的。好了，现在你知道程序中有个内存错误。</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 下再次运行该程序，你应该观察到相同的段错误。此时，尝试使用 <code class="docutils literal notranslate"><span class="pre">backtrace</span></code> 命令来定位程序崩溃时执行的位置。这个信息非常有用，但我们还需要更多！</p></li>
<li><p>退出 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 并在 Valgrind 下运行程序：<code class="docutils literal notranslate"><span class="pre">valgrind</span> <span class="pre">./buggy</span> <span class="pre">1</span></code>. Valgrind 的报告提供了更多详细的信息，包括内存错误的类型、执行的调用栈以及无效地址的值。此外，Valgrind 还检测到了段错误之前的一个问题——<strong>Use of uninitialised value of size 8</strong> 发生在 <strong>Invalid read of size 1</strong> 之前，前者是指针的大小，后者是 <code class="docutils literal notranslate"><span class="pre">char</span></code> 类型的大小。这个重要的信息可以引导你找到错误的根源！</p></li>
<li><p>重复上述过程，尝试解决错误 2 中的错误。错误 1 中的问题可能比较明显，但错误 2 中的问题仅凭肉眼很难发现——Valgrind 将非常有用！</p></li>
</ul>
<p>针对程序中的错误，Valgrind 使用的术语和报告可能很难理解。这需要一些练习来熟悉，你练习的目标应该是将 Valgrind 报告的错误与代码中的位置和根源联系起来。</p>
<p>我们选择这些特殊案例来进一步证明内存错误的棘手性。这两个错误都来自某种形式的内存错误，但观察到的后果却不同。 错误 1 每次都会因段错误而崩溃，而错误 2 的输出有时正确有时不正确，但它不会崩溃。</p>
<p>内存错误可能不会造成明显的损害，但这并不意味着程序是正确的，它只是这次“幸运”而已。使用 Valgrind 可以检测到这些潜在的错误，避免后续产生不可挽回的损失。</p>
<p>检查完这些错误后，请回答以下问题：处理字符串时，什么错误可能是 Valgrind 报告的“<strong>Conditional jump or move depends on uninitialised value(s)</strong>”的根本原因？这是你在作业 2 中可能会犯的错误，因此现在了解其原因很有必要！</p>
<blockquote>
<div><p><strong>启示</strong> 进行 Valgrind 例行检查</p>
<p>鉴于此，我们建议你在编写作业代码时，应该尽早并经常运行 Valgrind。每当 Valgrind 报告任何内存错误时，你就应该停下来并尝试解决它，然后再继续完成作业。让 Valgrind 的例行检查成为你的工作流的一部分，尤其是遇到错误时！</p>
</div></blockquote>
</section>
<section id="strtok">
<h2>任务 4：探究 strtok<a class="headerlink" href="#strtok" title="Link to this heading">#</a></h2>
<p>一种常见的字符串处理模式是将字符串拆分为“词元”或“token”。这些词元是由一个或多个分隔字符分隔出来的，例如将句子按空格拆分为单词或将文件路径按斜杠拆分为独立的组件。</p>
<p>C 标准库提供了一个 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 函数，但其​​笨拙的设计使得该函数的使用变得较为混乱且容易出错。我们将研究这个函数及其存在的问题，以此作为一个警示。在作业 2 中，你将编写一个改进的 <code class="docutils literal notranslate"><span class="pre">tokenize</span></code> 函数，在编写过程中要注意避免此类错误！</p>
<p>我们首先以用户身份来使用 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 函数。可以通过 <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">strtok</span></code> 熟悉其操作，注意 BUGS 部分中对该函数设计的批评。</p>
<p>与 C++ 等其他语言中类似的函数不同，只调用一次 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 并不会返回一个格式化好的类似 <code class="docutils literal notranslate"><span class="pre">vector</span></code> 一样的词元容器。相反，你必须重复调用 <code class="docutils literal notranslate"><span class="pre">strtok</span></code>，每次只能返回一个词元。直到 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时，才表示没有多余的词元。以下是一个常见的编程习语：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strtok</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">delims</span><span class="p">);</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">token</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">token</span><span class="p">);</span>
<span class="w">    </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">delims</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>关于 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 的诟病主要体现在两个方面，其一是它破坏性地修改了输入，其二是它一次只能处理一个词元。下面我们分别探讨下这些问题：</p>
<p><strong>设计问题  1：<code class="docutils literal notranslate"><span class="pre">strtok</span></code> 修改了传入的参数</strong>。 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 没有为每个词元创建一个新的子字符串，而是使用空字符 <code class="docutils literal notranslate"><span class="pre">NUL</span></code> 覆盖原字符串中的分割符，并返回指向首个词元的指针。该函数有效地将输入字符串分割成一系列词元，某种程度上，它重新利用了现有字符串，避免将字符复制到其他位置。例如字符串 <code class="docutils literal notranslate"><span class="pre">red-green-blue\0</span></code>，重复调用 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 以 <code class="docutils literal notranslate"><span class="pre">-</span></code> 进行分割后，该字符串将变为 <code class="docutils literal notranslate"><span class="pre">red\0green\0blue\0</span></code>。</p>
<p><strong>设计问题 2：<code class="docutils literal notranslate"><span class="pre">strtok</span></code> 不允许常量输入</strong>。该函数不仅破坏了输入参数，而且这种设计还无法处理字符串常量（只读）。程序 <code class="docutils literal notranslate"><span class="pre">token.c</span></code> 有一个示例，它将字符串常量作为输入传递给 <code class="docutils literal notranslate"><span class="pre">strtok</span></code>。取消该部分的代码注释，尝试编译并运行程序，看看 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 在处理字符串常量时的报错信息。</p>
<p><strong>设计问题 3：<code class="docutils literal notranslate"><span class="pre">strtok</span></code> 一次只能处理一个词元</strong>。在第一次调用 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 时，第一个参数是待处理的字符串。但在后续调用中，第一个参数将变为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，这是告诉 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 要从上一次调用的中断处，继续处理同一个字符串。在内部实现中，<code class="docutils literal notranslate"><span class="pre">strtok</span></code> 使用了一个全局变量来保存第一次调用时的原始输入字符串，并在后续调用中更新该变量。天哪！此行为与典型的函数调用形成了鲜明对比，典型的函数调用应该完全独立，不应该与任何先前或将来的调用相关联。这不仅让调试变得更困难，而且一次最多只能处理一个词元。该函数有一个状态变量，可以供所有调用共享。每次调用，函数都会将状态保存至该变量，再次调用函数时，会用新的值覆盖该变量。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">token.c</span></code> 中包含了一份 <code class="docutils literal notranslate"><span class="pre">strtok</span></code> 的实现，该实现改编自 <a class="reference external" href="https://musl.libc.org/">musl</a> 库。有很多谜题需要我们逐一揭开！绘制内存图并跟踪 <code class="docutils literal notranslate"><span class="pre">s</span></code> 和 <code class="docutils literal notranslate"><span class="pre">p</span></code> 在调用期间的变化，或者在 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 下运行该程序可能会有所帮助。</p>
<ul class="simple">
<li><p>第 12 行：关于<a class="reference external" href="https://en.wikipedia.org/wiki/Static_variable">静态变量</a>的维基百科页面提供了一些背景信息和静态局部变量的示例。 <code class="docutils literal notranslate"><span class="pre">static</span></code> 有什么作用？为什么要在这里使用它？
请注意，静态变量的初始化方式与非静态局部变量不同。尽管该函数看起来每次调用时都会声明一个新变量 <code class="docutils literal notranslate"><span class="pre">p</span></code> 并初始化，但<strong>静态变量只能被声明和初始化一次</strong>。在多次调用之间，<code class="docutils literal notranslate"><span class="pre">p</span></code> 的值将会保留，不会收回。</p></li>
<li><p>第 14~19 行：当 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 作为第一个参数传递时，<code class="docutils literal notranslate"><span class="pre">s</span></code> 如何获取值？</p></li>
<li><p>第 21 和 27 行：函数 <code class="docutils literal notranslate"><span class="pre">strspn</span></code> 和 <code class="docutils literal notranslate"><span class="pre">strcspn</span></code> 有何作用？</p></li>
<li><p>第 21 行：在这一行的执行过程中 <code class="docutils literal notranslate"><span class="pre">s</span></code> 是如何更新的？</p></li>
<li><p>第 22 行：表达式 <code class="docutils literal notranslate"><span class="pre">*s</span></code> 的计算结果是什么？这个表达式的另一种替代写法是什么？ （为了可读性，这种替代写法或许更好，但是唉……）</p></li>
<li><p>第 24 行：什么情况下函数会通过第 24 行退出？</p></li>
<li><p>第 27 行：执行完这一行后，<code class="docutils literal notranslate"><span class="pre">p</span></code> 指向哪里？</p></li>
<li><p>第 29 行：搞清楚这行代码的赋值操作，看它是如何改变输入参数的。该行执行结束后，<code class="docutils literal notranslate"><span class="pre">p</span></code> 指向哪里？</p></li>
<li><p>第 29 和 32 行：这两行似乎有些相似，都将 <code class="docutils literal notranslate"><span class="pre">0</span></code> 赋值给 <code class="docutils literal notranslate"><span class="pre">p</span></code>，但它们的目的却存在着重大差异。<code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">NULL</span></code>，<code class="docutils literal notranslate"><span class="pre">*p</span> <span class="pre">=</span> <span class="pre">'\0'</span> </code>与 <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">&quot;&quot;</span></code> 这些表达式有什么区别？</p></li>
</ul>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../assign_2/index.html">
              <div class="page-info">
                <div class="context">
                  <span>下一页</span>
                </div>
                <div class="title">作业 2. C 字符串</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../function_paremeters/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>上一页</span>
                </div>
                
                <div class="title">函数参数</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, <a href='https://www.stickmind.com/' target="_blank">StickMind</a>
            </div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            本页目录
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">实验 2. 数组和指针</a><ul>
<li><a class="reference internal" href="#id2">学习目标</a></li>
<li><a class="reference internal" href="#id3">初始代码</a></li>
<li><a class="reference internal" href="#gdb">任务 1：GDB 探究指针和数组</a></li>
<li><a class="reference internal" href="#atoi">任务 2：探究 atoi</a></li>
<li><a class="reference internal" href="#valgrind">任务 3：使用 Valgrind</a></li>
<li><a class="reference internal" href="#strtok">任务 4：探究 strtok</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=7d86a446"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/tabs.js?v=3ee01567"></script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    </body>
</html>