<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="prev" title="实验 4：泛型和回调" href="../lab_4/index.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>作业 4：深入泛型指针 - CS102 文档</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../../_static/pied-piper-admonition.css?v=e32e2275" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<div class="announcement">
  <aside class="announcement-content">
     Please use <a href='https://pradyunsg.me/furo/'>the main documentation</a> instead. 
  </aside>
</div>

<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">CS102 文档</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">CS102 文档</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_0.html">开发环境</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 开发环境</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_0/linux_intro/index.html">Linux 介绍</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Linux 介绍</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/linux_intro/linux_on_windows.html">Windows MSYS2 环境</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/linux_intro/linux_virtual_box.html">Ubuntu 虚拟机</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_0/command_line/linux_command.html">Linux 命令行</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Linux 命令行</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/command_line/basic.html">基本命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/command_line/file_operation.html">文件操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/command_line/searching.html">文件搜索</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../topic_0/from_cxx_to_c/from_cxx_to_c.html">从 C++ 到 C</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of 从 C++ 到 C</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/from_cxx_to_c/simpio.html">simpio.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/from_cxx_to_c/strlib.html">strlib.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../topic_0/from_cxx_to_c/pig_latin.html">Pig Latin</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_0/lab_0/index.html">实验 0：上手 Linux 开发环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_0/assign_0/index.html">作业 0：使用 Linux 和 C</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topic_1.html">数据的表示</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 数据的表示</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/lab_1/index.html">实验 1. 数据的表示</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topic_1/assign_1/index.html">作业 1. 有趣的位</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../topic_2.html">数组和指针</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../topic_3.html">栈和堆</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../topic_4.html">泛型编程</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of 泛型编程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../void_pointer/index.html">泛型指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="../function_pointer/index.html">函数指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lab_4/index.html">实验 4：泛型和回调</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">作业 4：深入泛型指针</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>作业 4：深入泛型指针<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<p>本次作业用于测试你对话题 4 的理解，你将实现 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 命令的简化版本。你的 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 命令可以使用多种方式打印出目录中的文件列表。你的 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 命令将按序打印文件中的行。</p>
<p>本次作业重点关注包含 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 的泛型编程、函数指针和泛型内存处理，并通过以下几个方面的训练，培养你的技能：</p>
<ul class="simple">
<li><p>理解 C 语言函数指针的目的并学会使用</p></li>
<li><p>以用户身份使用 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 泛型接口</p></li>
<li><p>使用原始内存操作实现 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 泛型函数</p></li>
</ul>
<p>完成作业后，你应该能够熟练地掌握内存管理，并能够使用/实现 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 泛型接口。最关键的是能够正确地传递/接收变幻莫测的 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 指针：如何处理一级/多级指针的解引用，需要什么样的类型转换，如何在准确且必要的地方使用 <code class="docutils literal notranslate"><span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>。毫无疑问，你应该知道如何确定解引用的级别，并正确应用它。理解并能够推测出错误的后果也很有必要。</p>
<p>为了帮助你评估学习进度，对于每个作业/实验，我们罗列了一些要点，并提供了一些思考问题。在完成作业后，可以使用这些问题进行自我检查。如果你不能很好地回答这些问题，那么还需要进一步努力。</p>
<ul class="simple">
<li><p>为了读取输入，<code class="docutils literal notranslate"><span class="pre">mysort</span></code> 程序将每一行读入一个临时的栈内存中，该内存大小为最大值，然后将副本复制到大小合适的动态内存中进行持久存储。在类似的案例中，这种栈和堆的配合是一种常见的技术。考虑到栈和堆的特性，解释为什么这种方法是必要的或适当的。</p></li>
<li><p>函数 <code class="docutils literal notranslate"><span class="pre">strcmp</span></code> 与比较函数 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 和 <code class="docutils literal notranslate"><span class="pre">qsort</span></code> 的参数原型大致匹配。粗略的类型转换（例如 <code class="docutils literal notranslate"><span class="pre">scandir</span></code> 所展示的类型转换）可以用来消除编译器的类型不匹配报警，但这却是一个巨大的错误。作为回调函数的比较函数，<code class="docutils literal notranslate"><span class="pre">strcmp</span></code> 几乎从来都不是正确的选择。解释一下为什么。</p></li>
<li><p>阅读 <code class="docutils literal notranslate"><span class="pre">lfind</span></code> 的 <code class="docutils literal notranslate"><span class="pre">man</span></code> 手册并描述如何使用 <code class="docutils literal notranslate"><span class="pre">lfind</span></code> 配合适当的回调来重新实现 <code class="docutils literal notranslate"><span class="pre">strlen</span></code> 的功能。</p></li>
</ul>
<section id="id2">
<h2>内存和指针建议<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<ul>
<li><p><strong>栈与堆</strong>。需注意栈分配与堆分配的正确使用以及各自适用的场景。根据一般经验，除非需要动态分配的情况，否则首选栈分配。通常，这两种技术会在程序中一起使用。举个例子，要求动态分配的 C 字符串具有适当的大小，例如字符串“apple”需要 6 个字符的存储空间，不能多也不能少。一个惯用法是分配一个大小为最大值的栈缓冲区来临时存储不确定长度的字符串，一旦确定长度后，再将其复制到大小合适的动态分配的堆缓冲区中。这就是 <code class="docutils literal notranslate"><span class="pre">mysort</span></code> 的行读取代码运行的逻辑。</p></li>
<li><p><strong>动态调整大小</strong>。 <code class="docutils literal notranslate"><span class="pre">mysort</span></code> 程序事先并不知道输入中的行数，因此它先进行初始分配并根据需要进行增长。大小翻倍是一项经典技术，你会经常看到，例如上次作业中的 <code class="docutils literal notranslate"><span class="pre">read_line</span></code> 缓冲区的处理以及 <code class="docutils literal notranslate"><span class="pre">musl_scandir</span></code> 收集的目录中的文件列表。</p></li>
<li><p><strong>对分配请求进行防御</strong>。在现代系统上，你不太可能耗尽整个堆，但当堆损坏时也可能返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。无论哪种方式，分配失败都不会带来任何好处，因此最好在情况变得更糟之前停止一切。</p></li>
<li><p><strong>指针类型应该明确</strong>。如果你知道指针的类型，请务必使用其特定类型来声明。仅当指针类型未知或可能变化时才使用 <code class="docutils literal notranslate"><span class="pre">void*</span></code>。另一方面，声明 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 指针时，也不要指定特定类型。将 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 声明为 <code class="docutils literal notranslate"><span class="pre">char*</span></code> 会误导读者认为该指针是 C 字符串，并可能造成误用，而且编译器不会出现警告。</p></li>
<li><p><strong>谨慎使用指针运算</strong>。尽管可以通过计算基地址的偏移量来访问普通数组元素或结构体字段，但为了可读性和安全性，你应该使用数组下标和结构体字段名称。尽可能在类型系统中工作，发挥强类型的长处。只有当你只能操作原始内存时，才有必要降级使用低级类型转换和指针运算。</p></li>
<li><p><strong>优选赋值操作，而不是原始的 <code class="docutils literal notranslate"><span class="pre">memcpy</span></code></strong>。虽然 <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> 可用于执行任何类型的赋值，但这并不意味着应该始终使用它。考虑以下三种整数赋值的方法：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">pDst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dst</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">pSrc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">;</span>

<span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">;</span><span class="w">                          </span><span class="c1">// option A</span>
<span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">pDst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">pSrc</span><span class="p">;</span><span class="w">          </span><span class="c1">// option B</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">pDst</span><span class="p">,</span><span class="w"> </span><span class="n">pSrc</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w">    </span><span class="c1">// option C</span>
</pre></div>
</div>
<p>三个选项都完成了相同的事情（将 4 字节整数从 <code class="docutils literal notranslate"><span class="pre">src</span></code> 复制到 <code class="docutils literal notranslate"><span class="pre">dst</span></code>）。选项A，普通的赋值语句是直接、干净、安全的。只要你能够在类型系统中工作，这始终是你的最佳选择。如果你被迫通过 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 进行操作，则必须考虑选项 B 和 C。选项 B（使用类型转换进行赋值）是你的第二个选择。该选项可读性好、高效且相对安全（给定正确的类型转换）。选项 C 在最低级别运行，没有任何类型安全保障。指针类型或大小的不匹配都是允许的，这会造成严重的破坏。当尝试读/写 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 的内容时，如果可能，请使用选项 B。仅当你别无选择时，才使用选项 C 的低级内存复制。根据经验：如果 <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> 的 <code class="docutils literal notranslate"><span class="pre">size</span></code> 参数是编译时常量（尤其是使用 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 时），则表明你不应该使用 <code class="docutils literal notranslate"><span class="pre">memcpy/memmove</span></code>。仅当在运行时确定要复制的内存类型/数量时，才需要调用原始字节复制。</p>
</li>
<li><p><strong>警惕类型转换</strong>。谨慎使用类型转换。你的类型转换破坏了类型系统，并强制编译器毫无怨言地接受它。这种力量伴随着巨大的责任。在使用转换之前，请考虑一下：为什么需要转换？如果不转换会发生什么？有没有更安全的方式来表达我的意图？如何在类型系统内工作而不是忽略它？（即纠正类型不匹配而不是用强制转换来掩盖）。</p>
<p>你永远不应该转换不变的值（而是修复类型！），转换函数指针也是一个欠考虑的举动（而是修复函数​​原型！）。你也永远不需要将任何内容强制转换为 <code class="docutils literal notranslate"><span class="pre">void*</span></code>，因为它是通用指针，并且与任何指针类型兼容（这样的强制转换是多余的，且可以删除）。当你需要一些类型转换时，要准确地添加它们，并且仅在必须的地方添加它们。如果你的代码重复使用类型转换的表达式，并且不可避免时，请考虑创建一个辅助函数来封装该表达式，以便在任何地方调用，而不是重复代码。</p>
</li>
</ul>
</section>
<section id="id3">
<h2>初始项目<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>你的个人用户目录下应该已经有 <code class="docutils literal notranslate"><span class="pre">cs102</span></code> 这个文件夹了，通过下面的命令拷贝初始代码到该目录中：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>cp<span class="w"> </span>-r<span class="w"> </span>/home/cs102-shared/assignments/assign4<span class="w"> </span>~/cs102
</pre></div>
</div>
</section>
<section id="scandir">
<h2>探究 scandir<a class="headerlink" href="#scandir" title="Link to this heading">#</a></h2>
<p>在随后的作业中，你将编写自己版本的 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 命令。为此，你需要以用户的身份使用 <code class="docutils literal notranslate"><span class="pre">scandir</span></code> 库函数，该函数用于为给定的路径创建一个目录列表（包含目录内文件名的一个字符串数组）。它还使用两个函数指针：一个是过滤函数，用于控制列表中包含哪些文件；另一个是比较函数，用于控制列表中文件名的顺序。</p>
<p>对 <code class="docutils literal notranslate"><span class="pre">scandir</span></code> 的理解对于实现 <code class="docutils literal notranslate"><span class="pre">myls</span></code> 至关重要，所以在使用它之前，我们先看看该函数是如何实现的。打开作业代码中的 <code class="docutils literal notranslate"><span class="pre">scandir.txt</span></code> 文件，该实现来自 <a class="reference external" href="https://git.musl-libc.org/cgit/musl/tree/src/dirent/scandir.c"><code class="docutils literal notranslate"><span class="pre">musl</span></code></a> 库。这个函数显示出了 C 的内在灵魂：函数指针、动态分配、三级指针，天哪！但是课程进行到此，你对 C 的了解已经足够深入，完全具备能力阅读这样的代码。慢慢来，尝试画图，有不懂的地方就问。</p>
<ul class="simple">
<li><p>查看 <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">readdir</span></code> 文档，了解 <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dirent</span></code> 的定义。一个奇怪的说明是，最后一个结构字段 <code class="docutils literal notranslate"><span class="pre">d_name</span></code> 是一个字符数组，描述为“未指定大小”。 该数组的大小是自适应的，用于存放指定目录的名称，包括一个终止字符。由此可见，系统默认的文件名称最多支持 255 个字符。</p></li>
<li><p>破译函数参数的类型。这是粘贴到 <a class="reference external" href="https://cdecl.org/?q=int+%28musl_scandir%29%28const+char+*%2C+struct+dirent+***%2C+int+%28*%29%28const+struct+dirent+*%29%2Cint+%28*%29%28const+struct+dirent+**%2C+const+struct+dirent+**%29%29">cdecl.org</a> 中的内容。画出 <code class="docutils literal notranslate"><span class="pre">scandir</span></code> 栈帧的内存布局图，包括所有参数和局部变量。跟踪代码时使用该图来查看内存中发生的情况。</p></li>
<li><p>这个三级指针 <code class="docutils literal notranslate"><span class="pre">res</span></code> 参数相当可怕。这个参数有什么作用呢？为什么需要三级指针？（提示：看一下第 43 行，该行使用了这个参数。那里的代码在做什么？回顾课上讨论的模型，如果主调函数希望通过调用一个函数来修改某个值，那么需要以传地址的方式调用，即指针）。</p></li>
<li><p>用户在调用这个函数时，如何表明不希望对文件名列表进行过滤？或者不进行排序？</p></li>
<li><p>变量名 <code class="docutils literal notranslate"><span class="pre">len</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cnt</span></code> 的选择对于表明其用途毫无帮助。变量 <code class="docutils literal notranslate"><span class="pre">names</span></code> 也具有误导性——这是一个字符串数组吗？</p></li>
<li><p>第 20 行使用了 <code class="docutils literal notranslate"><span class="pre">continue</span></code>，目前为止这可能是你从未见过的 C 结构。它在这里的目的是什么？虽然这个结构并不经常使用，但是当你遇到它时，有必要知道它的作用。</p></li>
<li><p>过滤器 <code class="docutils literal notranslate"><span class="pre">sel</span></code> 的非零结果是否会导致文件名在列表中保留或丢弃？</p></li>
<li><p>第 23 行几乎重复了我们在实验 3 的 <code class="docutils literal notranslate"><span class="pre">calloc</span></code> 中查看的一段代码。该测试的目的是什么？删除它会产生什么后果？</p></li>
<li><p>目录内文件的数量事先是未知的，因此 <code class="docutils literal notranslate"><span class="pre">scandir</span></code> 使用经典的“按需调整大小”分配策略来分配数组。这段代码看起来应该很熟悉，但有一些细节需要仔细检查：</p>
<ul>
<li><p>它在第 24 行调用 <code class="docutils literal notranslate"><span class="pre">realloc</span></code>，而没有对 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 进行初始调用。这样使用为什么也是有效的？（提示：查看 <code class="docutils literal notranslate"><span class="pre">realloc</span></code> 文档，了解如何处理该特殊情况）</p></li>
<li><p>它使用表达式 <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">*</span> <span class="pre">sizeof(*names)</span></code> 来计算总字节数。如果名称为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则该表达式似乎间接引用了一个 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，但请牢记 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 表达式不会运行，它只是根据表达式的类型（在编译期）确定该类型的大小而已。</p></li>
<li><p>大小表达式可以等效地写为 <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">*</span> <span class="pre">sizeof(struct</span> <span class="pre">dirent</span> <span class="pre">*)</span></code>。使用 <code class="docutils literal notranslate"><span class="pre">sizeof(*names)</span></code> 而不显式使用类型名有什么好处？</p></li>
</ul>
</li>
<li><p>在第 24 行，它将 <code class="docutils literal notranslate"><span class="pre">realloc</span></code> 的返回值赋值给 <code class="docutils literal notranslate"><span class="pre">tmp</span></code>，并在 <code class="docutils literal notranslate"><span class="pre">if</span></code> 之后将指针从 <code class="docutils literal notranslate"><span class="pre">tmp</span></code> 拷贝到 <code class="docutils literal notranslate"><span class="pre">names</span></code>。为什么它不直接赋值给 <code class="docutils literal notranslate"><span class="pre">names</span></code>？</p></li>
<li><p>第 28~30 行创建了 <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dirent</span></code> 的堆副本。由于 <code class="docutils literal notranslate"><span class="pre">d_name</span></code> 字段大小自适应，它会分配大小合适的堆内存并复制内容。</p></li>
<li><p>第 15 行引入了一个神秘的 <code class="docutils literal notranslate"><span class="pre">errno</span></code>。阅读 <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">3</span> <span class="pre">errno</span></code> 的更多信息，了解其目的和功能。第 19 行对 <code class="docutils literal notranslate"><span class="pre">errno</span></code> 做了什么，为什么要引入一个 <code class="docutils literal notranslate"><span class="pre">old_errno</span></code>？如果发生分配失败的情况，<code class="docutils literal notranslate"><span class="pre">errno</span></code> 的值是多少？（提示：阅读 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 文档的 <code class="docutils literal notranslate"><span class="pre">NOTES</span></code> 部分）</p></li>
<li><p>第 42 行有点难以理解，它对传递给 <code class="docutils literal notranslate"><span class="pre">qsort</span></code> 的函数指针进行了类型转换。尝试在使用和不使用强制转换的情况下编译代码。如果没有转换的情况下，你会收到什么警告/错误？（转换函数指针是一件欠考虑的事情，通常应该避免，但他们选择在这里使用的原因是可以理解的。）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scandir</span></code> 过滤器函数接收的参数为 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dirent</span> <span class="pre">*</span></code>；比较函数接收的参数为 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dirent</span> <span class="pre">**</span></code>。为什么不一致？</p></li>
<li><p>跟踪 <code class="docutils literal notranslate"><span class="pre">malloc/free</span></code> 的调用，了解该函数中的内存分配和释放。函数退出后还需要执行哪些释放操作？调用者正确释放该内存的步骤是什么？</p></li>
</ul>
<p>完成这一部分是一项重大成就。这段代码中发生了很多事情，你应该为能够剖析如此密集的代码而感到疯狂和自豪！对 <code class="docutils literal notranslate"><span class="pre">scandir</span></code> 的理解对于实现 <code class="docutils literal notranslate"><span class="pre">myls</span></code> 至关重要，接下来接受新的挑战吧。</p>
</section>
<section id="myls">
<h2>实现 myls<a class="headerlink" href="#myls" title="Link to this heading">#</a></h2>
<p>你已经多次使用 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 来查看目录内的文件。现在轮到你来实现这个主力命令行程序的简化版本，这也是一个很好的函数指针练习。</p>
<p><code class="docutils literal notranslate"><span class="pre">myls</span></code> 程序的运行方式与标准 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 类似，但作了许多简化，也包含一些差异。虽然心理上将 <code class="docutils literal notranslate"><span class="pre">myls</span></code> 看作和标准 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 相同的程序可能会有所帮助，但请不要错误地尝试对比标准 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 的更复杂功能的输出结果。下面的列表列举了 <code class="docutils literal notranslate"><span class="pre">myls</span></code> 所需的功能。如果对 <code class="docutils literal notranslate"><span class="pre">myls</span></code> 的预期行为有疑问，请观察 <code class="docutils literal notranslate"><span class="pre">samples</span></code> 目录中示例程序的行为，而不是与标准 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 进行比较。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">myls</span></code> 可以使用零个或多个目录路径作为参数。它可以列出每个路径的文件内容。如果不带参数调用，<code class="docutils literal notranslate"><span class="pre">myls</span></code> 会打印当前目录 (<code class="docutils literal notranslate"><span class="pre">.</span></code>) 中的文件列表。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">myls</span></code> 仅支持目录路径作为参数。如果参数是某个文件或不存在的路径，它应该打印一条错误消息并跳过该参数。你应该调用 <code class="docutils literal notranslate"><span class="pre">error</span></code> 函数，将错误消息与示例程序进行完全匹配，使用类似的文本“<strong>cannot access __</strong>”，填写无效参数的名称，以及错误代码 <code class="docutils literal notranslate"><span class="pre">0</span></code> 和状态代码 <code class="docutils literal notranslate"><span class="pre">0</span></code>（程序仍然可以继续运行）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">myls</span></code> 每行只打印一个文件名。</p></li>
<li><p>除非使用 <code class="docutils literal notranslate"><span class="pre">-a</span></code> 标志调用，否则 <code class="docutils literal notranslate"><span class="pre">myls</span></code> 忽略以 <code class="docutils literal notranslate"><span class="pre">.</span></code> 开头的文件名。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">myls</span></code> 在打印目录内同样是目录的名称时，会添加尾部斜杠。注意，<a class="reference external" href="https://zh.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5">符号链接</a>（symbolic link）是一类特殊的文件，不属于目录，可以当作普通文件对待。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">myls</span></code> 默认按名称顺序打印目录中的文件，名称按字典顺序进行比较（即 <code class="docutils literal notranslate"><span class="pre">strcmp</span></code>）。如果使用 <code class="docutils literal notranslate"><span class="pre">-z</span></code> 标志调用，则排序顺序将改为按类型排序（目录在非目录之前）。遇到相同类型的文件，再按名称进行排序。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">myls</span></code> 不支持除 <code class="docutils literal notranslate"><span class="pre">-a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-z</span></code> 之外的命令行标志</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">myls</span></code> 应调用标准 <code class="docutils literal notranslate"><span class="pre">scandir</span></code> 函数，而不是重新实现其功能。鉴于 <code class="docutils literal notranslate"><span class="pre">scandir</span></code> 已经完成了 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 程序的大部分工作，你只需编写过滤/比较函数，对 <code class="docutils literal notranslate"><span class="pre">scandir</span></code> 进行一次调用，然后打印结果列表即可。作为补充，<code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">scandir</span></code> 的文档包含一个简短的示例程序。小提示：该示例程序碰巧以相反的顺序打印条目，这可能不是你想要的。小心不要从文档中直接复制粘贴代码，除非你认真审查过，了解它做了什么并知道如何根据需要进行调整。</p></li>
</ul>
<blockquote>
<div><p><strong>注意</strong></p>
<p>本次作业的一个重要限制是，不允许使用 C 标准库中的 <code class="docutils literal notranslate"><span class="pre">versionsort</span></code> 或 <code class="docutils literal notranslate"><span class="pre">alphasort</span></code> 函数作为回调函数参数。你应该实现自己的比较函数。</p>
</div></blockquote>
<p>文件 <code class="docutils literal notranslate"><span class="pre">myls.c</span></code> 为你提供了少量的代码来处理命令行参数。在开始之前，首先阅读并理解给定的代码，弄清楚如何将其合并到你的实现中，最后为你实现的代码以及初始代码添加注释。初始代码旨在帮助你入门，但你完全可以根据需要随意删除/修改这些代码。</p>
<p>你可以使用 <code class="docutils literal notranslate"><span class="pre">typedef</span></code> 为函数指针类型指定昵称，让代码更简洁。除了可以避免重复原始的语法，还可以更简单地创建该函数指针类型的变量。在文件 <code class="docutils literal notranslate"><span class="pre">mysort.c</span></code> 中也有该用法的示例。</p>
<p>处理命令行参数也是一项繁琐的工作。 GNU 的扩展 <code class="docutils literal notranslate"><span class="pre">getopt</span></code> 在一定程度上，有助于简化这个操作。使用 <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">3</span> <span class="pre">getopt</span></code> 了解有关其工作原理的更多信息。使用 <code class="docutils literal notranslate"><span class="pre">getopt</span></code> 时如何检测并报告无效的选项？</p>
</section>
<section id="bsearch">
<h2>探究 bsearch<a class="headerlink" href="#bsearch" title="Link to this heading">#</a></h2>
<p>接下来，你将学习以下代码，以便实现一个通用的二分插入函数，即使用二分搜索高效地将元素插入到一个有序数组中。在稍后的作业中，你将使用它作为 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 命令实现的一部分。编写一个正确的二分搜索函数本身就相当困难，而实现一个通用的 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 函数只会增加挑战。如果需要复习二分搜索算法，可以查看 CS101 配套课本。</p>
<p>我们提供了一份来自 <a class="reference external" href="https://opensource.apple.com/source/gcc/gcc-5659/libiberty/bsearch.c.auto.html">bsearch.c (apple.com)</a> 的通用二分搜索 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 的代码。稍后你将修改此实现，作为你自己的 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 函数的一部分，因此了解它的工作原理非常重要。请仔细研究！如果你还没有完成实验 4 中有关 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 的练习，那么现在可以继续巩固这些知识。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">apple_bsearch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span>
<span class="w">                    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nmemb</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">compar</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">nremain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nmemb</span><span class="p">;</span><span class="w"> </span><span class="n">nremain</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">nremain</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">nremain</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compar</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sign</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sign</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="cm">/* key &gt; p: move right */</span>
<span class="w">            </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">            </span><span class="n">nremain</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w">       </span><span class="cm">/* else move left */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>在实验 1 中，我们阅读了 Joshua Bloch 的文章 <a class="reference external" href="https://research.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">Nearly All Binary Searches and Mergesorts are Broken</a>，讨论了实现中点计算的问题。 Apple 的 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 实现是否存在文章中指出的错误？解释下原因。</p></li>
<li><p>注释 <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">else</span> <span class="pre">move</span> <span class="pre">left</span> <span class="pre">*/</span></code> 似乎注释了一个空的 <code class="docutils literal notranslate"><span class="pre">else</span></code> 语句块。当符号为负时，搜索如何向左移动呢？</p></li>
<li><p>对 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 执行指针算术运算是非法的，因此强制转换为 <code class="docutils literal notranslate"><span class="pre">char*</span></code>。在实验 4 中，我们研究过 <code class="docutils literal notranslate"><span class="pre">musl_memmove</span></code>，它将其 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 参数复制到函数开头的 <code class="docutils literal notranslate"><span class="pre">char*</span></code> 类型的局部变量中，从而避免了转换的必要。相比之下，Apple 的 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 将其参数保留为 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 并在每个指针算术运算之前显式强制转换。这种处理背后的依据是 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 类型传达了该指针的特殊性质，不会误导用户认为该参数是一个普通的 C 字符串。保持它的 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 属性还意味着，如果你不小心对其执行解引用或指针算术运算，编译器会报警。每次对 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 的操作都需要显式强制转换，这种故意的类型转换强调了程序员的设计意图。</p></li>
<li><p>假设变量 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arr</span></code> 是数组的基地址，<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*found</span></code> 是搜索到的元素的地址，<code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">width</span></code> 是每个元素的大小（以字节为单位），那么将 <code class="docutils literal notranslate"><span class="pre">found</span></code> 转换为其相应的数组索引的 C 表达式是什么？</p></li>
</ul>
<p>完成这一步是一项巨大的成就。这段代码中发生了很多事情，你应该感到自豪，因为你可以理解这样的库代码了，还能利用它来实现一个通用的二分搜索！有了这些知识储备，你就可以开始编写 <code class="docutils literal notranslate"><span class="pre">binsert</span></code>，这是 Apple <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 的一个变体。</p>
</section>
<section id="binsert">
<h2>实现 binsert<a class="headerlink" href="#binsert" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">lfind</span></code> 和 <code class="docutils literal notranslate"><span class="pre">lsearch</span></code> 是泛型线性搜索函数，阅读 <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">lsearch</span></code> 了解更多介绍。<code class="docutils literal notranslate"><span class="pre">lsearch</span></code> 与 <code class="docutils literal notranslate"><span class="pre">lfind</span></code> 的区别在于，如果没有找到元素，<code class="docutils literal notranslate"><span class="pre">lsearch</span></code> 会将搜索关键字添加到数组中。该特性非常方便！</p>
<p>你的下一个任务是编写一个通用函数 <code class="docutils literal notranslate"><span class="pre">binsert</span></code>，它是 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 的变体，具有相同的功能；对 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 的调用将对“键值”执行二分搜索，如果找不到匹配元素，则会将键值插入到有序数组中的正确位置。该函数在作业的最后一个任务中会派上用场，你可以利用其实现自己版本的 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 命令。以下是 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 函数原型：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">binsert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">p_nelem</span><span class="p">,</span><span class="w"> </span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">compar</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">));</span>
</pre></div>
</div>
<p>以下是该函数操作的详细信息：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">binsert</span></code> 的参数设计参照了 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 的参数（查看 <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">bsearch</span></code>）。唯一的区别是将元素的数量作为指针传递。这是必须的，因为 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 将在将新元素插入数组时更新计数。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 没有找到匹配的元素，它将把键值插入到数组的正确位置并增加元素的数量。客户端有责任确保数组有足够的空间来容纳新的元素。<code class="docutils literal notranslate"><span class="pre">binsert</span></code> 不会分配、调整或释放客户端提供的数组内存。</p></li>
<li><p>该函数返回一个指向匹配的数组成员的指针，如果未找到现有匹配项，则返回指向新添加的成员的指针。</p></li>
<li><p>你可以将 Apple <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 的代码复制/粘贴到 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 中作为初始代码。 虽然在 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 直接调用 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 可以避免代码重复，但是搜索不到元素时，标准 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 不会提供必要的位置信息，而这些信息在你正确插入新元素时非常重要。如果你调用 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 并得到了否定结果，你就必须进行二次搜索才能找到该位置，这意味着代码冗余和重复执行！所以，把 <code class="docutils literal notranslate"><span class="pre">bsearch</span></code> 代码拷贝到 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 中进行调整，反而可以让该函数只需要执行一次搜索。提示：你可能不需要对提供的代码进行特别大的修改，修改应该不到 10 行。如果你修改了太多的代码，很可能是你对其行为的理解出现了偏差。</p></li>
<li><p>如果需要移动数组中的元素来腾出空间，你应该使用 <code class="docutils literal notranslate"><span class="pre">memmove</span></code>，而不是循环逐个移动数组项，<code class="docutils literal notranslate"><span class="pre">memmove</span></code> 可以一次性移动整个数组！</p></li>
</ul>
<p>将你的实现写入 <code class="docutils literal notranslate"><span class="pre">util.c</span></code> 文件中。你可以单独编写并测试该函数，然后在稍后编写 <code class="docutils literal notranslate"><span class="pre">mysort</span></code> 程序时使用该函数。你可以使用我们提供的 <code class="docutils literal notranslate"><span class="pre">test_binsert.c</span></code> 程序测试你的 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 函数。 <code class="docutils literal notranslate"><span class="pre">test_binsert</span></code> 程序与 <code class="docutils literal notranslate"><span class="pre">sanitycheck</span></code> 集成，方便你进行测试。注意：除了 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-s</span></code> 标志之外，<code class="docutils literal notranslate"><span class="pre">test_binsert</span></code> 不支持带有负数或以 <code class="docutils literal notranslate"><span class="pre">-</span></code> 开头的字符串的输入。有关如何使用它的更多信息，请参阅 <code class="docutils literal notranslate"><span class="pre">test_binsert.c</span></code> 文件。</p>
<p>在继续下一个任务之前，你是否彻底测试了 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 的实现？增量开发是开发过程的一个重要部分，你可以单独实现一个个小模块，<strong>彻底</strong>测试它们，然后在确定它们的正确性后再进行整合。这样的好处是，如果某一步遇到了错误，你可以确信错误来源就是你最近修改的代码，缩小排查的范围。<code class="docutils literal notranslate"><span class="pre">mysort</span></code> 建立在这段代码的基础上，因此在继续之前，请确保对其正确性充满信心。</p>
</section>
<section id="mysort">
<h2>实现 mysort<a class="headerlink" href="#mysort" title="Link to this heading">#</a></h2>
<p>对于作业的最后部分，你将实现你自己的 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 命令，称为 <code class="docutils literal notranslate"><span class="pre">mysort</span></code>，它将使用 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 函数作为底层实现。<code class="docutils literal notranslate"><span class="pre">sort</span></code> 是另一个过滤器命令，类似 <code class="docutils literal notranslate"><span class="pre">uniq</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tail</span></code>，你在上次作业中已经实现了它们的简化版本。标准 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 命令逐行读取输入，然后按指定顺序打印出各行。它支持各种命令行标志控制排序的行为。以下是 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 的使用示例：</p>
<div class="highlight-Shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cat<span class="w"> </span>samples/colors
red
green
green
red
blue
blue
blue
red

$<span class="w"> </span>sort<span class="w"> </span>samples/colors<span class="w"> </span>
blue
blue
blue
green
green
red
red
red

$<span class="w"> </span>sort<span class="w"> </span>-u<span class="w"> </span>-r<span class="w"> </span>samples/colors<span class="w"> </span>
red
green
blue
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mysort</span></code> 程序的运行方式与标准 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 类似，但有许多简化和一些差异。虽然心理上将 <code class="docutils literal notranslate"><span class="pre">mysort</span></code> 看作和标准 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 相同的程序可能会有所帮助，但请不要错误地尝试对比标准 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 的更复杂功能的输出结果。如果对 <code class="docutils literal notranslate"><span class="pre">mysort</span></code> 的预期行为有疑问，请观察 <code class="docutils literal notranslate"><span class="pre">samples</span></code> 目录中示例程序的行为，而不是与标准 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 进行比较。</p>
<p>以下是 <code class="docutils literal notranslate"><span class="pre">mysort</span></code> 所需的功能：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mysort</span></code> 读取一个文件：指定文件（由参数指定）或标准输入（参数未指定）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mysort</span></code> 的默认排序顺序是字典顺序（字母顺序）。</p></li>
<li><p>如果使用 <code class="docutils literal notranslate"><span class="pre">-l</span></code> 标志调用，则排序顺序是按行的长度递增。</p></li>
<li><p>如果使用 <code class="docutils literal notranslate"><span class="pre">-n</span></code> 标志调用，则排序顺序按字符串数值（将 <code class="docutils literal notranslate"><span class="pre">atoi</span></code> 应用于每一行并比较数字）。</p></li>
<li><p>如果是重复行，即根据排序规则，比较结果相等的行，则可以按任意顺序输出。</p></li>
<li><p>如果使用 <code class="docutils literal notranslate"><span class="pre">-r</span></code> 标志调用，则排序顺序将相反。（提示：对输入进行常规排序，只需更改打印时的顺序即可）</p></li>
<li><p>如果使用 <code class="docutils literal notranslate"><span class="pre">-u</span></code> 标志调用，则丢弃重复的行。排序后的输出只包含输入中互不相同的行。根据排序顺序来确定哪些行是重复的（例如，如果按长度排序，则长度相同的两行被视为重复）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mysort</span></code> 的标志可以单独使用或组合使用。如果同时使用 <code class="docutils literal notranslate"><span class="pre">-l</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-n</span></code>，则命令行上最后一个标志将用作排序顺序。</p></li>
<li><p>除了 <code class="docutils literal notranslate"><span class="pre">-l</span> <span class="pre">-n</span> <span class="pre">-r</span> <span class="pre">-u</span></code> 之外，<code class="docutils literal notranslate"><span class="pre">mysort</span></code> 不支持其他任何命令行标志。</p></li>
</ul>
<p>在底层实现中，<code class="docutils literal notranslate"><span class="pre">mysort</span></code> 应该具有以下行为：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mysort</span></code> 使用 <code class="docutils literal notranslate"><span class="pre">fgets</span></code> 将一行内容读取到栈数组中。该栈数组的大小应设置为最大大小（参阅 <code class="docutils literal notranslate"><span class="pre">MAX_LINE_LEN</span></code> 常量，预估一个较大的值）。对于超过最大长度的输入行，我们不会对其进行任何测试。你还可以假设所有输入行都以换行符结束，这可以避免在输入的最后一行出现特殊情况。</p></li>
<li><p>读取要存储的行后，应将其复制到适当大小的动态堆内存中进行存储。此时，函数 <code class="docutils literal notranslate"><span class="pre">strdup</span></code> 会很方便。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mysort</span></code> 应该能够处理任意行数的输入。如此大的行数组对于栈内存来说可能太大了，因此这个数组必须是在堆内存上分配的。由于无法提前确定行数，所以 <code class="docutils literal notranslate"><span class="pre">mysort</span></code> 应该将数组分配为一个最小初始数量（请参阅 <code class="docutils literal notranslate"><span class="pre">MIN_NLINES</span></code> 常量），然后每次填满时，将其大小加倍。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mysort</span></code> 的 <code class="docutils literal notranslate"><span class="pre">-u</span></code> 选项必须重复调用 <code class="docutils literal notranslate"><span class="pre">binsert</span></code> 函数。这里要求对所有重复行仅存储一次，而不是存储所有的行，再将重复的删除。另外，此处不应该调用 <code class="docutils literal notranslate"><span class="pre">qsort</span></code>。</p></li>
<li><p>如果在没有 <code class="docutils literal notranslate"><span class="pre">-u</span></code> 标志的情况下执行，<code class="docutils literal notranslate"><span class="pre">mysort</span></code> 应该只调用一次 <code class="docutils literal notranslate"><span class="pre">qsort</span></code> 并且不会调用 <code class="docutils literal notranslate"><span class="pre">binsert</span></code>。</p></li>
</ul>
<p>重要提示：在实现过程中，如果你需要存储某一行，则仅应在堆上存储。另外，如果不需要存储该行并在稍后进行打印，则不应在堆上分配内存。如果你的内存使用量明显高于示例程序，则可能是因为这个原因。</p>
<p>这可能看起来与之前的作业相似，你最初可能会倾向于复制粘贴之前的代码，但最终应该意识到此实现中存在着一些显着的差异。与上一个作业不同，本次作业需要<strong>使用不同的策略</strong>来读取未知大小的文本——先将其分配在栈上，然后仅在知道完整大小后才使用堆内存进行分配，因为此时才能准确分配你需要的内存大小来存储数据。</p>
<p>不同的方法各有利弊。对于本次作业，你可能会采取上一份作业使用的方法，由于没有使用栈内存进行预先存储，在堆上分配的空间将略多于所需的大小。而本次作业推荐的策略，将使用大量栈空间来存储初始字符串，最终的结果是你可以精准地分配所需的堆内存大小。我们希望通过这两次作业，能够让你充分练习这两种有效的开发模式。</p>
<p>文件 <code class="docutils literal notranslate"><span class="pre">mysort.c</span></code> 为你提供了少量的代码来处理命令行参数。在开始之前，首先阅读并理解给定的代码，弄清楚如何将其合并到你的实现中，最后为你实现的代码以及初始代码添加注释。初始代码旨在帮助你入门，但你完全可以根据需要随意删除/修改这些代码。</p>
<p><code class="docutils literal notranslate"><span class="pre">mysort</span></code> 的一个核心目标是<strong>如何在不重复代码或使代码过于复杂的情况下，优雅地处理排序选项的组合</strong>。特别注意，4 个命令行标志都可以独立地打开，总共有 24 种不同组合。如果你考虑不周，最终可能会从每个组合中创建一个不同的情况，以至于多出 16 倍的代码量。相反，如果你能够统一共同的操作，只在个别差异的地方添加代码来处理，那么可以少走很多弯路。你可能需要不断迭代来解决很多细节，但如果用心去做，最终你将会得到一个非常令人满意的结果！加油吧！</p>
<p>最后，强烈建议你阅读：<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.14.8162&amp;amp;rep=rep1&amp;amp;type=pdf">Engineering a Sort Function</a>。这篇文章是关于 <code class="docutils literal notranslate"><span class="pre">qsort</span></code> 库函数的思想和工程实践的精彩读物。Jon Bentley 和 Doug McIlroy 是前贝尔实验室的两位名人堂成员，他们写的任何东西都值得一读！</p>
<blockquote>
<div><p><strong>FAQ</strong> 如何使用 <code class="docutils literal notranslate"><span class="pre">sanitycheck</span></code> 检测较长输出</p>
<p>最后一个测试使用一份很长的数字文件进行排序。如果通过测试，则不会打印整个输出，但如果输出不匹配，那么它将打印整个差异信息，这可能很烦人。</p>
<p>除了在终端中滚动查看输出结果，一个更方便的技巧是使用管道 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 将测试结果保存到一个文件中。需要注意的是，由于输出的格式和颜色问题，文件中可能会显示一些奇怪的字符。解决方法是，可以使用以下命令，使用正确的格式打开文件：<code class="docutils literal notranslate"><span class="pre">less</span> <span class="pre">-R</span> <span class="pre">outputfile.txt</span></code>。总结一下这些步骤：</p>
<div class="highlight-Shell notranslate"><div class="highlight"><pre><span></span><span class="w">	</span>$<span class="w"> </span>sanitycheck<span class="w"> </span>&gt;<span class="w"> </span>outputfile.txt<span class="w"> </span>
<span class="w">	</span>$<span class="w"> </span>less<span class="w"> </span>-R<span class="w"> </span>outputfile.txt
</pre></div>
</div>
</div></blockquote>
</section>
<section id="id4">
<h2>测试与提交<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>作为作业的一部分，你应该尽可能完善 <code class="docutils literal notranslate"><span class="pre">custom_tests</span></code> 中的测试案例，至少添加 3 到 5 个。为了更好的可读性，也建议你为代码和测试用例编写注释或文档。这些注释用于说明每个测试的初衷，以及这些测试之间的相互关系。</p>
<p>作业提交方式参考作业 0，可以使用 <code class="docutils literal notranslate"><span class="pre">submit</span></code> 提交你的代码。为了追求完美，一些加分项值得你去注意：</p>
<ul class="simple">
<li><p>编译是否干净，有无警告等编译错误？</p></li>
<li><p>默认测试是否全部通过？</p></li>
<li><p>自定义测试案例是否全面？</p></li>
</ul>
<p>对于代码实现部分：</p>
<ul class="simple">
<li><p>有没有其他地方，还可以使用位运算进行改写？</p></li>
<li><p>算法是否高效？还记得如何分析算法复杂度吗？</p></li>
<li><p>代码风格及可读性是否注意过？有没有进行函数拆分，提取出一些更通用的代码？</p></li>
<li><p>有没有尝试编写文档？一份好的代码就如同一篇优美的散文，不多一字，也不少一字。加油！</p></li>
</ul>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="../lab_4/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">实验 4：泛型和回调</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, <a href='https://www.stickmind.com/' target="_blank">StickMind</a>
            </div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">作业 4：深入泛型指针</a><ul>
<li><a class="reference internal" href="#id2">内存和指针建议</a></li>
<li><a class="reference internal" href="#id3">初始项目</a></li>
<li><a class="reference internal" href="#scandir">探究 scandir</a></li>
<li><a class="reference internal" href="#myls">实现 myls</a></li>
<li><a class="reference internal" href="#bsearch">探究 bsearch</a></li>
<li><a class="reference internal" href="#binsert">实现 binsert</a></li>
<li><a class="reference internal" href="#mysort">实现 mysort</a></li>
<li><a class="reference internal" href="#id4">测试与提交</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=7d86a446"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/tabs.js?v=3ee01567"></script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    </body>
</html>